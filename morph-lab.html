<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FloAng Morph Lab - Continuous Vector Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #e0e0e0;
            font-family: 'Monaco', monospace;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #controls {
            width: 350px;
            background: #1a1a1a;
            border-right: 2px solid #333;
            padding: 20px;
            overflow-y: auto;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        canvas {
            border: 1px solid #333;
            background: #0a0a0a;
        }

        h1 {
            color: #6cf;
            font-size: 18px;
            margin-bottom: 20px;
            border-bottom: 2px solid #6cf;
            padding-bottom: 10px;
        }

        h2 {
            color: #f6c;
            font-size: 14px;
            margin: 20px 0 10px 0;
        }

        .param {
            margin: 15px 0;
        }

        .param label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }

        .param input[type="range"] {
            width: 100%;
        }

        .param .value {
            color: #6cf;
            font-weight: bold;
            float: right;
        }

        button {
            background: #6cf;
            color: #0a0a0a;
            border: none;
            padding: 10px 20px;
            font-family: 'Monaco', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            margin: 5px 5px 5px 0;
            transition: background 0.2s;
        }

        button:hover {
            background: #8ef;
        }

        button:active {
            background: #4ad;
        }

        #hall-of-shame {
            background: #1a0a0a;
            border: 1px solid #600;
            padding: 10px;
            margin-top: 20px;
            font-size: 10px;
            color: #f66;
            max-height: 200px;
            overflow-y: auto;
        }

        #hall-of-shame h3 {
            color: #f66;
            font-size: 11px;
            margin-bottom: 5px;
        }

        #hall-of-shame li {
            margin: 3px 0;
            padding-left: 10px;
            list-style-position: inside;
        }

        .metrics {
            background: #0a1a0a;
            border: 1px solid #060;
            padding: 10px;
            margin-top: 10px;
            font-size: 10px;
            color: #6f6;
        }

        .metrics span {
            display: block;
            margin: 2px 0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1>ðŸ§ª FloAng Morph Lab</h1>
        <p style="font-size: 10px; color: #666; margin-bottom: 20px;">
            Continuous vector-based morphing system
        </p>

        <h2>Current State</h2>
        <div class="param">
            <label>Sides: <span class="value" id="sides-value">3</span></label>
            <input type="range" id="sides" min="3" max="12" step="1" value="3">
        </div>
        <div class="param">
            <label>Flow: <span class="value" id="flow-value">-0.66</span></label>
            <input type="range" id="flow" min="-3" max="1" step="0.01" value="-0.66">
        </div>
        <div class="param">
            <label>Angle: <span class="value" id="angle-value">60Â°</span></label>
            <input type="range" id="angle" min="20" max="160" step="1" value="60">
        </div>

        <h2>Morph Parameters</h2>
        <div class="param">
            <label>Duration (ms): <span class="value" id="duration-value">3000</span></label>
            <input type="range" id="duration" min="500" max="10000" step="100" value="3000">
        </div>
        <div class="param">
            <label>Easing Power: <span class="value" id="easing-value">3</span></label>
            <input type="range" id="easing" min="1" max="5" step="0.1" value="3">
        </div>
        <div class="param">
            <label>Insertion Position: <span class="value" id="insertion-value">0.50</span></label>
            <input type="range" id="insertion" min="0" max="1" step="0.01" value="0.5">
        </div>
        <div class="param">
            <label>Emergence Speed: <span class="value" id="emergence-value">1.0</span></label>
            <input type="range" id="emergence" min="0.1" max="3" step="0.1" value="1.0">
        </div>
        <div class="param">
            <label>Symmetry Weight: <span class="value" id="symmetry-value">1.0</span></label>
            <input type="range" id="symmetry-weight" min="0" max="2" step="0.1" value="1.0">
        </div>

        <h2>Actions</h2>
        <button onclick="startMorph()">â–¶ Start Morph (n â†’ n+1)</button>
        <button onclick="resetState()">âŸ² Reset</button>
        <button onclick="addFailure()">ðŸ’€ Add Failure</button>

        <div class="metrics" id="metrics">
            <strong>Live Metrics:</strong>
            <span>Progress: <span id="progress-metric">0%</span></span>
            <span>Symmetry Score: <span id="symmetry-metric">-</span></span>
            <span>Anchor Count: <span id="anchor-metric">0</span></span>
        </div>

        <div id="hall-of-shame">
            <h3>ðŸ’€ Hall of Shame: What Didn't Workâ„¢</h3>
            <ul id="failure-list">
                <li>Linear interpolation of anchor positions - caused asymmetry collapse</li>
                <li>Equal spacing enforcement - fought with natural curve flow</li>
            </ul>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas" width="800" height="800"></canvas>
    </div>

    <script>
        /**
         * FloAng Morph Lab - Continuous Vector Animation System
         *
         * Core Concept: Instead of discretizing anchor points on a circle,
         * we represent them as continuous vectors with position, velocity,
         * and handle control points. This allows smooth morphing.
         */

        // ===== CORE DATA STRUCTURES =====

        /**
         * Anchor Point - Continuous vector representation
         */
        class AnchorPoint {
            constructor(x, y) {
                this.pos = { x, y };           // Position vector
                this.handleIn = { x: 0, y: 0 }; // Incoming handle (relative to pos)
                this.handleOut = { x: 0, y: 0 }; // Outgoing handle (relative to pos)
                this.velocity = { x: 0, y: 0 }; // For physics-based movement
                this.targetPos = null;          // Target position during morph
            }

            // Calculate absolute handle positions
            getHandleInAbs() {
                return {
                    x: this.pos.x + this.handleIn.x,
                    y: this.pos.y + this.handleIn.y
                };
            }

            getHandleOutAbs() {
                return {
                    x: this.pos.x + this.handleOut.x,
                    y: this.pos.y + this.handleOut.y
                };
            }

            // Set handles from flow and angle parameters
            setHandlesFromParams(flow, angle, nextAnchor) {
                const apex = GeometryUtils.calculateApex(this.pos, nextAnchor.pos, angle);
                const handles = GeometryUtils.calculateHandlesFromApex(
                    this.pos,
                    nextAnchor.pos,
                    apex,
                    flow
                );

                this.handleOut = handles.handleOut;
                nextAnchor.handleIn = handles.handleIn;
            }
        }

        /**
         * Shape - Collection of anchor points forming a closed path
         */
        class Shape {
            constructor(anchors = []) {
                this.anchors = anchors;
            }

            // Create n-sided polygon
            static createPolygon(sides, radius, centerX, centerY, rotation = 0) {
                const anchors = [];
                const angleStep = (2 * Math.PI) / sides;
                const rotRad = (rotation * Math.PI) / 180;

                for (let i = 0; i < sides; i++) {
                    const angle = rotRad + i * angleStep;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    anchors.push(new AnchorPoint(x, y));
                }

                return new Shape(anchors);
            }

            // Apply flow/angle parameters to all edges
            applyParams(flow, angle) {
                for (let i = 0; i < this.anchors.length; i++) {
                    const anchor = this.anchors[i];
                    const nextAnchor = this.anchors[(i + 1) % this.anchors.length];
                    anchor.setHandlesFromParams(flow, angle, nextAnchor);
                }
            }

            // Calculate comprehensive symmetry score
            calculateSymmetry() {
                if (this.anchors.length < 3) return 0;

                let totalError = 0;
                const n = this.anchors.length;

                // 1. Check edge length variance
                const edgeLengths = [];
                for (let i = 0; i < n; i++) {
                    const a1 = this.anchors[i];
                    const a2 = this.anchors[(i + 1) % n];
                    const dx = a2.pos.x - a1.pos.x;
                    const dy = a2.pos.y - a1.pos.y;
                    edgeLengths.push(Math.sqrt(dx * dx + dy * dy));
                }
                const meanEdgeLength = edgeLengths.reduce((a, b) => a + b, 0) / n;
                const edgeLengthVariance = edgeLengths.reduce((sum, len) =>
                    sum + Math.pow(len - meanEdgeLength, 2), 0) / n;
                totalError += edgeLengthVariance;

                // 2. Check angular distances from center
                const center = { x: 400, y: 400 }; // Known center
                const distances = [];
                for (let i = 0; i < n; i++) {
                    const dx = this.anchors[i].pos.x - center.x;
                    const dy = this.anchors[i].pos.y - center.y;
                    distances.push(Math.sqrt(dx * dx + dy * dy));
                }
                const meanDistance = distances.reduce((a, b) => a + b, 0) / n;
                const distanceVariance = distances.reduce((sum, dist) =>
                    sum + Math.pow(dist - meanDistance, 2), 0) / n;
                totalError += distanceVariance;

                // 3. Check handle magnitude variance (should be similar)
                const handleMagnitudes = [];
                for (let i = 0; i < n; i++) {
                    const anchor = this.anchors[i];
                    const magIn = Math.sqrt(anchor.handleIn.x ** 2 + anchor.handleIn.y ** 2);
                    const magOut = Math.sqrt(anchor.handleOut.x ** 2 + anchor.handleOut.y ** 2);
                    handleMagnitudes.push(magIn, magOut);
                }
                const meanHandleMag = handleMagnitudes.reduce((a, b) => a + b, 0) / handleMagnitudes.length;
                const handleVariance = handleMagnitudes.reduce((sum, mag) =>
                    sum + Math.pow(mag - meanHandleMag, 2), 0) / handleMagnitudes.length;
                totalError += handleVariance * 0.1; // Less weight on handles

                return totalError;
            }

            clone() {
                const newAnchors = this.anchors.map(a => {
                    const clone = new AnchorPoint(a.pos.x, a.pos.y);
                    clone.handleIn = { ...a.handleIn };
                    clone.handleOut = { ...a.handleOut };
                    return clone;
                });
                return new Shape(newAnchors);
            }
        }

        /**
         * Geometry Utilities - Reusable geometric calculations
         */
        class GeometryUtils {
            /**
             * Calculate orthogonal angle for n-sided polygon
             * This is the "perfect symmetry" angle where all edges are equal
             */
            static calculateOrthogonalAngle(sides) {
                return ((sides - 2) * 180) / sides;
            }

            /**
             * Calculate perpendicular vector to (dx, dy)
             * Returns normalized perpendicular with its length
             */
            static calculatePerpendicular(dx, dy) {
                const perpX = dy;
                const perpY = -dx;
                const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
                return { perpX, perpY, perpLength };
            }

            /**
             * Calculate apex point for bezier curve given two anchor positions,
             * an angle, and the edge vector between them
             */
            static calculateApex(p1, p2, angleDegrees) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const baseLength = Math.sqrt(dx * dx + dy * dy);

                const { perpX, perpY, perpLength } = this.calculatePerpendicular(dx, dy);

                const apexAngle = (angleDegrees * Math.PI) / 180;
                const height = (baseLength / 2) / Math.tan(apexAngle / 2);
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                const apexX = midX + (perpX / perpLength) * height;
                const apexY = midY + (perpY / perpLength) * height;

                return { x: apexX, y: apexY };
            }

            /**
             * Calculate handle vectors from an apex point for two anchors
             * Returns { handleOut, handleIn } suitable for assignment
             */
            static calculateHandlesFromApex(anchor1, anchor2, apex, flow) {
                return {
                    handleOut: {
                        x: (apex.x - anchor1.x) * flow,
                        y: (apex.y - anchor1.y) * flow
                    },
                    handleIn: {
                        x: (apex.x - anchor2.x) * flow,
                        y: (apex.y - anchor2.y) * flow
                    }
                };
            }

            /**
             * Evaluate cubic bezier curve at parameter t
             */
            static evaluateBezier(p0, cp1, cp2, p3, t) {
                const mt = 1 - t;
                const mt2 = mt * mt;
                const mt3 = mt2 * mt;
                const t2 = t * t;
                const t3 = t2 * t;

                return {
                    x: mt3 * p0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * p3.x,
                    y: mt3 * p0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * p3.y
                };
            }

            /**
             * Calculate tangent vector of cubic bezier at parameter t
             */
            static calculateBezierTangent(p0, cp1, cp2, p3, t) {
                const mt = 1 - t;
                const mt2 = mt * mt;
                const t2 = t * t;

                const dx = 3 * (mt2 * (cp1.x - p0.x) + 2 * mt * t * (cp2.x - cp1.x) + t2 * (p3.x - cp2.x));
                const dy = 3 * (mt2 * (cp1.y - p0.y) + 2 * mt * t * (cp2.y - cp1.y) + t2 * (p3.y - cp2.y));

                return { dx, dy, length: Math.sqrt(dx * dx + dy * dy) };
            }

            /**
             * Linearly interpolate between two vectors
             */
            static lerp(v1, v2, t) {
                return {
                    x: v1.x + (v2.x - v1.x) * t,
                    y: v1.y + (v2.y - v1.y) * t
                };
            }

            /**
             * Calculate distance between two points
             */
            static distance(p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            /**
             * Calculate magnitude of a vector
             */
            static magnitude(v) {
                return Math.sqrt(v.x * v.x + v.y * v.y);
            }
        }

        // ===== STATE =====

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let currentShape = null;
        let morphState = {
            active: false,
            startTime: 0,
            fromShape: null,
            toShape: null,
            progress: 0
        };

        // Parameters (read from UI)
        const params = {
            sides: 3,
            flow: -0.66,
            angle: 60,
            duration: 3000,
            easingPower: 3,
            insertionPosition: 0.5,
            emergenceSpeed: 1.0,
            symmetryWeight: 1.0
        };

        // ===== INITIALIZATION =====

        function init() {
            // Create initial shape
            currentShape = Shape.createPolygon(params.sides, 250, 400, 400, 0);
            currentShape.applyParams(params.flow, params.angle);

            // Setup UI listeners
            setupUIListeners();

            // Start render loop
            requestAnimationFrame(render);
        }

        function setupUIListeners() {
            // Update parameters from UI
            document.getElementById('sides').addEventListener('input', (e) => {
                params.sides = parseInt(e.target.value);
                document.getElementById('sides-value').textContent = params.sides;
                if (!morphState.active) {
                    currentShape = Shape.createPolygon(params.sides, 250, 400, 400, 0);
                    currentShape.applyParams(params.flow, params.angle);
                }
            });

            document.getElementById('flow').addEventListener('input', (e) => {
                params.flow = parseFloat(e.target.value);
                document.getElementById('flow-value').textContent = params.flow.toFixed(2);
                if (!morphState.active) {
                    currentShape.applyParams(params.flow, params.angle);
                }
            });

            document.getElementById('angle').addEventListener('input', (e) => {
                params.angle = parseFloat(e.target.value);
                document.getElementById('angle-value').textContent = params.angle + 'Â°';
                if (!morphState.active) {
                    currentShape.applyParams(params.flow, params.angle);
                }
            });

            document.getElementById('duration').addEventListener('input', (e) => {
                params.duration = parseInt(e.target.value);
                document.getElementById('duration-value').textContent = params.duration;
            });

            document.getElementById('easing').addEventListener('input', (e) => {
                params.easingPower = parseFloat(e.target.value);
                document.getElementById('easing-value').textContent = params.easingPower.toFixed(1);
            });

            document.getElementById('insertion').addEventListener('input', (e) => {
                params.insertionPosition = parseFloat(e.target.value);
                document.getElementById('insertion-value').textContent = params.insertionPosition.toFixed(2);
            });

            document.getElementById('emergence').addEventListener('input', (e) => {
                params.emergenceSpeed = parseFloat(e.target.value);
                document.getElementById('emergence-value').textContent = params.emergenceSpeed.toFixed(1);
            });

            document.getElementById('symmetry-weight').addEventListener('input', (e) => {
                params.symmetryWeight = parseFloat(e.target.value);
                document.getElementById('symmetry-value').textContent = params.symmetryWeight.toFixed(1);
            });
        }

        // ===== MORPH LOGIC =====

        // ===== SNAPSHOT DEBUGGING =====
        const snapshots = {
            before: null,
            justAfter: null,
            finished: null
        };

        function captureSnapshot(shape, label) {
            if (!shape || shape.anchors.length < 2) return null;

            // Create SVG path data
            let pathData = `M ${shape.anchors[0].pos.x} ${shape.anchors[0].pos.y}`;

            for (let i = 0; i < shape.anchors.length; i++) {
                const anchor = shape.anchors[i];
                const nextAnchor = shape.anchors[(i + 1) % shape.anchors.length];
                const cp1 = anchor.getHandleOutAbs();
                const cp2 = nextAnchor.getHandleInAbs();

                pathData += ` C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${nextAnchor.pos.x} ${nextAnchor.pos.y}`;
            }
            pathData += ' Z';

            // Capture relative handle vectors for each anchor
            const anchorData = [];
            for (let i = 0; i < shape.anchors.length; i++) {
                const anchor = shape.anchors[i];
                anchorData.push({
                    index: i,
                    pos: { x: anchor.pos.x.toFixed(2), y: anchor.pos.y.toFixed(2) },
                    handleIn: { x: anchor.handleIn.x.toFixed(4), y: anchor.handleIn.y.toFixed(4) },
                    handleOut: { x: anchor.handleOut.x.toFixed(4), y: anchor.handleOut.y.toFixed(4) }
                });
            }

            // Calculate edge angles
            const edgeAngles = [];
            for (let i = 0; i < shape.anchors.length; i++) {
                const anchor = shape.anchors[i];
                const nextAnchor = shape.anchors[(i + 1) % shape.anchors.length];
                const dx = nextAnchor.pos.x - anchor.pos.x;
                const dy = nextAnchor.pos.y - anchor.pos.y;
                const baseLength = Math.sqrt(dx * dx + dy * dy);

                const cp1 = anchor.getHandleOutAbs();
                const height = Math.abs((cp1.y - anchor.pos.y) * dx - (cp1.x - anchor.pos.x) * dy) / baseLength;
                const angle = Math.atan((2 * height) / (baseLength / 2)) * (180 / Math.PI);
                edgeAngles.push(angle.toFixed(2));
            }

            return {
                label,
                pathData,
                anchors: shape.anchors.length,
                symmetry: shape.calculateSymmetry().toFixed(4),
                edgeAngles: edgeAngles.join(', '),
                anchorData: anchorData,
                params: {
                    flow: params.flow.toFixed(2),
                    angle: params.angle.toFixed(0)
                }
            };
        }

        function displaySnapshots() {
            console.log('\n=== SNAPSHOT COMPARISON ===');
            console.log('BEFORE:', snapshots.before);
            console.log('JUST AFTER:', snapshots.justAfter);
            console.log('FINISHED:', snapshots.finished);

            // Create visual comparison with handle data
            // Paths use absolute coords with center at (400,400), so we translate to offset them
            const svg = `
<svg width="1400" height="900" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1400 900">
    <rect width="1400" height="900" fill="#0a0a0a"/>

    <!-- Before -->
    <g transform="translate(-200, 50)">
        <path d="${snapshots.before?.pathData || ''}" fill="rgba(135,206,235,0.3)" stroke="#4682b4" stroke-width="2"/>
        <text x="400" y="50" fill="#fff" text-anchor="middle" font-size="14" font-weight="bold">BEFORE</text>
        <text x="400" y="70" fill="#aaa" text-anchor="middle" font-size="10">Anchors: ${snapshots.before?.anchors || 0}</text>
        <text x="400" y="85" fill="#aaa" text-anchor="middle" font-size="10">Symmetry: ${snapshots.before?.symmetry || 0}</text>
        <text x="400" y="100" fill="#aaa" text-anchor="middle" font-size="10">Flow: ${snapshots.before?.params.flow || 0}, Angle: ${snapshots.before?.params.angle || 0}Â°</text>
        <text x="400" y="115" fill="#aaa" text-anchor="middle" font-size="9">Angles: ${snapshots.before?.edgeAngles || ''}</text>
    </g>

    <!-- Just After -->
    <g transform="translate(200, 50)">
        <path d="${snapshots.justAfter?.pathData || ''}" fill="rgba(255,165,0,0.3)" stroke="#ff8c00" stroke-width="2"/>
        <text x="400" y="50" fill="#fff" text-anchor="middle" font-size="14" font-weight="bold">JUST AFTER START</text>
        <text x="400" y="70" fill="#aaa" text-anchor="middle" font-size="10">Anchors: ${snapshots.justAfter?.anchors || 0}</text>
        <text x="400" y="85" fill="#aaa" text-anchor="middle" font-size="10">Symmetry: ${snapshots.justAfter?.symmetry || 0}</text>
        <text x="400" y="100" fill="#aaa" text-anchor="middle" font-size="10">Flow: ${snapshots.justAfter?.params.flow || 0}, Angle: ${snapshots.justAfter?.params.angle || 0}Â°</text>
        <text x="400" y="115" fill="#aaa" text-anchor="middle" font-size="9">Angles: ${snapshots.justAfter?.edgeAngles || ''}</text>
    </g>

    <!-- Finished -->
    <g transform="translate(600, 50)">
        <path d="${snapshots.finished?.pathData || ''}" fill="rgba(0,255,0,0.3)" stroke="#00ff00" stroke-width="2"/>
        <text x="400" y="50" fill="#fff" text-anchor="middle" font-size="14" font-weight="bold">FINISHED</text>
        <text x="400" y="70" fill="#aaa" text-anchor="middle" font-size="10">Anchors: ${snapshots.finished?.anchors || 0}</text>
        <text x="400" y="85" fill="#aaa" text-anchor="middle" font-size="10">Symmetry: ${snapshots.finished?.symmetry || 0}</text>
        <text x="400" y="100" fill="#aaa" text-anchor="middle" font-size="10">Flow: ${snapshots.finished?.params.flow || 0}, Angle: ${snapshots.finished?.params.angle || 0}Â°</text>
        <text x="400" y="115" fill="#aaa" text-anchor="middle" font-size="9">Angles: ${snapshots.finished?.edgeAngles || ''}</text>
    </g>
</svg>`;

            console.log('SVG comparison:\n' + svg);

            // Save to file for viewing
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'morph-snapshots.svg';
            a.click();
        }

        function startMorph() {
            if (morphState.active) return;

            const fromSides = params.sides;
            const toSides = fromSides + 1;

            // Clone current shape as starting point
            morphState.fromShape = currentShape.clone();

            // CAPTURE SNAPSHOT: BEFORE
            snapshots.before = captureSnapshot(currentShape, 'BEFORE');

            // Create target shape with n+1 sides
            morphState.toShape = Shape.createPolygon(toSides, 250, 400, 400, 0);
            morphState.toShape.applyParams(params.flow, params.angle);

            // Start morph animation
            morphState.active = true;
            morphState.startTime = performance.now();
            morphState.progress = 0;

            // Reset snapshot flags
            snapshots.justAfter = null;
            snapshots.finished = null;

            console.log(`Starting morph: ${fromSides} â†’ ${toSides} sides`);
        }

        function updateMorph(timestamp) {
            if (!morphState.active) return;

            const elapsed = timestamp - morphState.startTime;
            morphState.progress = Math.min(elapsed / params.duration, 1);
            const easedProgress = easeInOutCubic(morphState.progress, params.easingPower);

            // TODO: Implement continuous morph algorithm here
            // For now, just lerp the shapes
            currentShape = lerpShapes(morphState.fromShape, morphState.toShape, easedProgress);

            // CAPTURE SNAPSHOT: JUST AFTER START (around 1-2% progress)
            if (!snapshots.justAfter && morphState.progress > 0.01 && morphState.progress < 0.03) {
                snapshots.justAfter = captureSnapshot(currentShape, 'JUST AFTER');
                console.log('Captured JUST AFTER snapshot at progress:', (morphState.progress * 100).toFixed(1) + '%');
            }

            // Update metrics
            document.getElementById('progress-metric').textContent = (morphState.progress * 100).toFixed(1) + '%';
            document.getElementById('symmetry-metric').textContent = currentShape.calculateSymmetry().toFixed(4);
            document.getElementById('anchor-metric').textContent = currentShape.anchors.length;

            // Check if complete
            if (morphState.progress >= 1) {
                // CAPTURE SNAPSHOT: FINISHED
                snapshots.finished = captureSnapshot(currentShape, 'FINISHED');
                console.log('Captured FINISHED snapshot');

                // Display all snapshots
                displaySnapshots();

                morphState.active = false;
                params.sides++;
                document.getElementById('sides').value = params.sides;
                document.getElementById('sides-value').textContent = params.sides;
                console.log('Morph complete');
            }
        }

        /**
         * Morph algorithm: Insert new anchor and normalize to orthogonality
         *
         * Value Change Log:
         * - initialRatio: 0.2 â†’ maintains smooth curve continuity at insertion
         * - Removed result.applyParams() call â†’ was causing abrupt angle changes to ALL anchors
         * - ALL edges now transition toward toOrthogonal angle
         * - currentAngle = fromOrthogonal + (toOrthogonal - fromOrthogonal) * t (for non-emerging edges)
         * - emergingEdgeAngle = halfwayAngle + (toOrthogonal - halfwayAngle) * t (for emerging edges)
         * - halfwayAngle = fromOrthogonal + (toOrthogonal - fromOrthogonal) * 0.5
         * - Edge (newAnchorIdx-1)â†’newAnchorIdx uses emergingEdgeAngle (starts at halfway)
         * - Edge newAnchorIdxâ†’0 uses emergingEdgeAngle (starts at halfway)
         * - All other edges use currentAngle (starts at fromOrthogonal, transitions to toOrthogonal)
         * - Final state: ALL edges reach toOrthogonal angle, forming perfect T-shapes at each anchor
         * - Separate apex calculations for handleIn and handleOut â†’ proper bezier curve formation
         * - Set anchor[0].handleIn in STEP 3 using emergingEdgeAngle â†’ matches emergingAnchor.handleOut apex
         *
         * Steps:
         * 1. Insert new anchor between anchor[0] and anchor[-1]
         * 2. Gradually normalize all parameters (positions + angles) to maintain orthogonality
         */
        function lerpShapes(from, to, t) {
            const fromSides = from.anchors.length;
            const toSides = fromSides + 1;

            // Calculate orthogonal angles
            const fromOrthogonal = GeometryUtils.calculateOrthogonalAngle(fromSides);
            const toOrthogonal = GeometryUtils.calculateOrthogonalAngle(toSides);

            // Create result shape starting from 'from'
            const result = from.clone();

            // STEP 1: Insert new anchor between anchor[0] and anchor[-1]
            if (t > 0 && result.anchors.length === fromSides) {
                const lastAnchor = result.anchors[fromSides - 1];
                const firstAnchor = result.anchors[0];

                // Sample the BEZIER CURVE between last and first anchors
                // This is the actual visible path, not the circular arc!
                const insertT = params.insertionPosition;

                // Get the bezier control points
                const p0 = lastAnchor.pos;
                const cp1 = lastAnchor.getHandleOutAbs();
                const cp2 = firstAnchor.getHandleInAbs();
                const p3 = firstAnchor.pos;

                // Evaluate cubic bezier at t to find point along the curve
                const newPos = GeometryUtils.evaluateBezier(p0, cp1, cp2, p3, insertT);

                // Create new anchor at the point along the bezier curve
                const newAnchor = new AnchorPoint(newPos.x, newPos.y);

                // Calculate initial handles using De Casteljau subdivision
                // This maintains curve continuity when splitting the bezier

                // Derivative at t (tangent direction)
                const tangent = GeometryUtils.calculateBezierTangent(p0, cp1, cp2, p3, insertT);

                // Set handles as a ratio of the tangent direction
                // Start with a small ratio that will grow to final values
                const initialRatio = 0.2; // Start at 20% of final handle length
                const handleLength = tangent.length * insertT * initialRatio;

                // Normalize tangent and scale
                if (tangent.length > 0) {
                    const normDx = tangent.dx / tangent.length;
                    const normDy = tangent.dy / tangent.length;

                    newAnchor.handleIn.x = -normDx * handleLength;
                    newAnchor.handleIn.y = -normDy * handleLength;
                    newAnchor.handleOut.x = normDx * handleLength;
                    newAnchor.handleOut.y = normDy * handleLength;
                } else {
                    newAnchor.handleIn = { x: 0, y: 0 };
                    newAnchor.handleOut = { x: 0, y: 0 };
                }

                // Insert it at the end (between last and first when path closes)
                result.anchors.push(newAnchor);

                // IMMEDIATELY store the handle values on the ORIGINAL 'from' shape anchors
                // This persists across frames since 'result' is cloned from 'from' each frame
                const newAnchorIdx = result.anchors.length - 1;
                if (!from.anchors[newAnchorIdx - 1]._storedHandleOut) {
                    from.anchors[newAnchorIdx - 1]._storedHandleOut = {
                        x: result.anchors[newAnchorIdx - 1].handleOut.x,
                        y: result.anchors[newAnchorIdx - 1].handleOut.y
                    };
                    console.log(`[INIT] Stored anchor[${newAnchorIdx - 1}].handleOut:`,
                        from.anchors[newAnchorIdx - 1]._storedHandleOut);
                }
                if (!from.anchors[0]._storedHandleIn) {
                    from.anchors[0]._storedHandleIn = {
                        x: result.anchors[0].handleIn.x,
                        y: result.anchors[0].handleIn.y
                    };
                    console.log(`[INIT] Stored anchor[0].handleIn:`,
                        from.anchors[0]._storedHandleIn);
                }

                // Copy stored values to result anchors for this frame
                result.anchors[newAnchorIdx - 1]._storedHandleOut = from.anchors[newAnchorIdx - 1]._storedHandleOut;
                result.anchors[0]._storedHandleIn = from.anchors[0]._storedHandleIn;
            }

            // STEP 2: Gradually normalize all parameters
            if (result.anchors.length === toSides) {
                // ALL edges transition toward toOrthogonal at the same rate
                // No special treatment for edges adjacent to emerging anchor
                const currentAngle = fromOrthogonal + (toOrthogonal - fromOrthogonal) * t;

                // Debug logging at key moments
                if (t < 0.01 || t > 0.99) {
                    console.log(`t=${t.toFixed(3)}: fromOrth=${fromOrthogonal.toFixed(1)}Â° toOrth=${toOrthogonal.toFixed(1)}Â° currentAngle=${currentAngle.toFixed(1)}Â°`);
                }

                // Move new anchor outward from edge to final position
                const newAnchor = result.anchors[result.anchors.length - 1];
                const targetAnchor = to.anchors[to.anchors.length - 1];

                // Lerp position towards target
                newAnchor.pos.x = newAnchor.pos.x + (targetAnchor.pos.x - newAnchor.pos.x) * t * params.emergenceSpeed;
                newAnchor.pos.y = newAnchor.pos.y + (targetAnchor.pos.y - newAnchor.pos.y) * t * params.emergenceSpeed;

                // Gradually adjust all anchor positions to maintain symmetry
                // Redistribute anchors evenly around the circle
                const radius = 250; // Same as initial creation
                const center = { x: 400, y: 400 };
                const angleStep = (2 * Math.PI) / toSides;

                for (let i = 0; i < result.anchors.length; i++) {
                    const targetAngle = i * angleStep;
                    const targetX = center.x + radius * Math.cos(targetAngle);
                    const targetY = center.y + radius * Math.sin(targetAngle);

                    const currentAnchor = result.anchors[i];

                    // Smoothly interpolate towards target position
                    // Use symmetry weight to control how aggressively we enforce symmetry
                    const normalizationStrength = t * params.symmetryWeight;
                    currentAnchor.pos.x = currentAnchor.pos.x + (targetX - currentAnchor.pos.x) * normalizationStrength;
                    currentAnchor.pos.y = currentAnchor.pos.y + (targetY - currentAnchor.pos.y) * normalizationStrength;
                }

                // Identify the emerging anchor
                const newAnchorIdx = result.anchors.length - 1;

                // Recalculate handles for ALL edges
                for (let i = 0; i < result.anchors.length; i++) {
                    const anchor = result.anchors[i];
                    const nextAnchor = result.anchors[(i + 1) % result.anchors.length];

                    // Identify edges adjacent to emerging anchor
                    const isEdgeBeforeEmerging = (i === newAnchorIdx - 1);
                    const isEdgeAfterEmerging = (i === newAnchorIdx);

                    // All edges use currentAngle
                    const edgeAngle = currentAngle;

                    // Calculate target handles using angle-based formula
                    const apex = GeometryUtils.calculateApex(anchor.pos, nextAnchor.pos, edgeAngle);
                    const handles = GeometryUtils.calculateHandlesFromApex(
                        anchor.pos,
                        nextAnchor.pos,
                        apex,
                        params.flow
                    );
                    const targetHandleOut = handles.handleOut;
                    const targetHandleIn = handles.handleIn;

                    // For edges adjacent to emerging anchor, interpolate from stored initial values
                    // For other edges (including emerging anchor itself), set directly to target
                    if (isEdgeBeforeEmerging && anchor._storedHandleOut) {
                        // Edge before emerging: interpolate anchor[newAnchorIdx-1].handleOut
                        anchor.handleOut.x = anchor._storedHandleOut.x + (targetHandleOut.x - anchor._storedHandleOut.x) * t;
                        anchor.handleOut.y = anchor._storedHandleOut.y + (targetHandleOut.y - anchor._storedHandleOut.y) * t;

                        if (t < 0.02 || t > 0.98) {
                            console.log(`[t=${t.toFixed(3)}] anchor[${i}].handleOut: stored=(${anchor._storedHandleOut.x.toFixed(2)},${anchor._storedHandleOut.y.toFixed(2)}) target=(${targetHandleOut.x.toFixed(2)},${targetHandleOut.y.toFixed(2)}) result=(${anchor.handleOut.x.toFixed(2)},${anchor.handleOut.y.toFixed(2)})`);
                        }
                    } else if (!isEdgeAfterEmerging) {
                        // Non-adjacent edges: set directly
                        anchor.handleOut.x = targetHandleOut.x;
                        anchor.handleOut.y = targetHandleOut.y;
                    }
                    // Note: emerging anchor's handleOut is handled in STEP 3

                    if (isEdgeAfterEmerging && nextAnchor._storedHandleIn) {
                        // Edge after emerging: interpolate anchor[0].handleIn
                        nextAnchor.handleIn.x = nextAnchor._storedHandleIn.x + (targetHandleIn.x - nextAnchor._storedHandleIn.x) * t;
                        nextAnchor.handleIn.y = nextAnchor._storedHandleIn.y + (targetHandleIn.y - nextAnchor._storedHandleIn.y) * t;

                        if (t < 0.02 || t > 0.98) {
                            console.log(`[t=${t.toFixed(3)}] anchor[${(i+1) % result.anchors.length}].handleIn: stored=(${nextAnchor._storedHandleIn.x.toFixed(2)},${nextAnchor._storedHandleIn.y.toFixed(2)}) target=(${targetHandleIn.x.toFixed(2)},${targetHandleIn.y.toFixed(2)}) result=(${nextAnchor.handleIn.x.toFixed(2)},${nextAnchor.handleIn.y.toFixed(2)})`);
                        }
                    } else if (!isEdgeBeforeEmerging) {
                        // Non-adjacent edges: set directly
                        nextAnchor.handleIn.x = targetHandleIn.x;
                        nextAnchor.handleIn.y = targetHandleIn.y;
                    }
                    // Note: emerging anchor's handleIn is handled in STEP 3
                }

                // STEP 3: Ease new anchor's handles from tangent to orthogonal
                const emergingAnchor = result.anchors[newAnchorIdx];

                // Calculate what the INITIAL tangent-based handles were
                // (Re-calculate from scratch each frame to ensure consistency)
                const lastAnchor = result.anchors[newAnchorIdx - 1];
                const firstAnchor = result.anchors[0];

                const p0 = lastAnchor.pos;
                const cp1Initial = {
                    x: p0.x + lastAnchor.handleOut.x,
                    y: p0.y + lastAnchor.handleOut.y
                };
                const cp2Initial = {
                    x: firstAnchor.pos.x + firstAnchor.handleIn.x,
                    y: firstAnchor.pos.y + firstAnchor.handleIn.y
                };
                const p3 = firstAnchor.pos;

                const insertT = params.insertionPosition;

                // Tangent at insertion point
                const tangent = GeometryUtils.calculateBezierTangent(p0, cp1Initial, cp2Initial, p3, insertT);
                const initialHandleIn = { x: 0, y: 0 };
                const initialHandleOut = { x: 0, y: 0 };

                if (tangent.length > 0) {
                    const normDx = tangent.dx / tangent.length;
                    const normDy = tangent.dy / tangent.length;
                    const initialRatio = 0.2;
                    const handleLength = tangent.length * insertT * initialRatio;

                    initialHandleIn.x = -normDx * handleLength;
                    initialHandleIn.y = -normDy * handleLength;
                    initialHandleOut.x = normDx * handleLength;
                    initialHandleOut.y = normDy * handleLength;
                }

                // Calculate target handles for emerging anchor using currentAngle
                // (Do NOT call applyParams - that would change ALL anchors)
                const prevAnchor = result.anchors[newAnchorIdx - 1];
                const nextAnchor = result.anchors[0]; // wraps around to first anchor

                // Calculate handleOut apex (between emergingAnchor and nextAnchor)
                const apexOut = GeometryUtils.calculateApex(emergingAnchor.pos, nextAnchor.pos, currentAngle);

                // Calculate handleIn apex (between prevAnchor and emergingAnchor)
                const apexIn = GeometryUtils.calculateApex(prevAnchor.pos, emergingAnchor.pos, currentAngle);

                // Calculate target orthogonal handles
                const targetHandleOut = {
                    x: (apexOut.x - emergingAnchor.pos.x) * params.flow,
                    y: (apexOut.y - emergingAnchor.pos.y) * params.flow
                };
                const targetHandleIn = {
                    x: (apexIn.x - emergingAnchor.pos.x) * params.flow,
                    y: (apexIn.y - emergingAnchor.pos.y) * params.flow
                };

                // Interpolate from initial tangent-based to final orthogonal
                emergingAnchor.handleIn.x = initialHandleIn.x + (targetHandleIn.x - initialHandleIn.x) * t;
                emergingAnchor.handleIn.y = initialHandleIn.y + (targetHandleIn.y - initialHandleIn.y) * t;
                emergingAnchor.handleOut.x = initialHandleOut.x + (targetHandleOut.x - initialHandleOut.x) * t;
                emergingAnchor.handleOut.y = initialHandleOut.y + (targetHandleOut.y - initialHandleOut.y) * t;

                // Also set anchor[0].handleIn to match the same apex as emergingAnchor.handleOut
                // (They share the same edge emergingAnchorâ†’anchor[0], both point to same apex)
                // Use the TARGET orthogonal apex, not eased (only emerging anchor's handles ease)
                const anchor0 = result.anchors[0];
                anchor0.handleIn.x = (apexOut.x - anchor0.pos.x) * params.flow;
                anchor0.handleIn.y = (apexOut.y - anchor0.pos.y) * params.flow;
            }

            return result;
        }

        function easeInOutCubic(t, power) {
            return t < 0.5
                ? Math.pow(2, power - 1) * Math.pow(t, power)
                : 1 - Math.pow(-2 * t + 2, power) / 2;
        }

        // ===== RENDERING =====

        function render(timestamp) {
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update morph if active
            if (morphState.active) {
                updateMorph(timestamp);
            }

            // Draw current shape
            if (currentShape) {
                drawShape(currentShape);
            }

            requestAnimationFrame(render);
        }

        function drawShape(shape) {
            if (shape.anchors.length < 2) return;

            ctx.strokeStyle = '#4682b4';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(135, 206, 235, 0.3)';

            // Draw the path
            ctx.beginPath();
            const firstAnchor = shape.anchors[0];
            ctx.moveTo(firstAnchor.pos.x, firstAnchor.pos.y);

            for (let i = 0; i < shape.anchors.length; i++) {
                const anchor = shape.anchors[i];
                const nextAnchor = shape.anchors[(i + 1) % shape.anchors.length];

                const cp1 = anchor.getHandleOutAbs();
                const cp2 = nextAnchor.getHandleInAbs();

                ctx.bezierCurveTo(
                    cp1.x, cp1.y,
                    cp2.x, cp2.y,
                    nextAnchor.pos.x, nextAnchor.pos.y
                );
            }

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw anchor points
            shape.anchors.forEach(anchor => {
                ctx.fillStyle = '#ff00ff';
                ctx.beginPath();
                ctx.arc(anchor.pos.x, anchor.pos.y, 4, 0, Math.PI * 2);
                ctx.fill();

                // Draw handles
                ctx.strokeStyle = '#f66';
                ctx.lineWidth = 1;
                const outAbs = anchor.getHandleOutAbs();
                ctx.beginPath();
                ctx.moveTo(anchor.pos.x, anchor.pos.y);
                ctx.lineTo(outAbs.x, outAbs.y);
                ctx.stroke();

                ctx.fillStyle = '#f66';
                ctx.beginPath();
                ctx.arc(outAbs.x, outAbs.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ===== UI ACTIONS =====

        function resetState() {
            morphState.active = false;
            currentShape = Shape.createPolygon(params.sides, 250, 400, 400, 0);
            currentShape.applyParams(params.flow, params.angle);
        }

        function addFailure() {
            const failure = prompt('What didn\'t work?');
            if (failure) {
                const list = document.getElementById('failure-list');
                const li = document.createElement('li');
                li.textContent = failure;
                list.appendChild(li);
            }
        }

        // Start the lab!
        init();
    </script>
</body>
</html>
