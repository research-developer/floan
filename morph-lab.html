<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FloAng Morph Lab - Continuous Vector Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #e0e0e0;
            font-family: 'Monaco', monospace;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #controls {
            width: 350px;
            background: #1a1a1a;
            border-right: 2px solid #333;
            padding: 20px;
            overflow-y: auto;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        canvas {
            border: 1px solid #333;
            background: #0a0a0a;
        }

        h1 {
            color: #6cf;
            font-size: 18px;
            margin-bottom: 20px;
            border-bottom: 2px solid #6cf;
            padding-bottom: 10px;
        }

        h2 {
            color: #f6c;
            font-size: 14px;
            margin: 20px 0 10px 0;
        }

        .param {
            margin: 15px 0;
        }

        .param label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }

        .param input[type="range"] {
            width: 100%;
        }

        .param .value {
            color: #6cf;
            font-weight: bold;
            float: right;
        }

        button {
            background: #6cf;
            color: #0a0a0a;
            border: none;
            padding: 10px 20px;
            font-family: 'Monaco', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            margin: 5px 5px 5px 0;
            transition: background 0.2s;
        }

        button:hover {
            background: #8ef;
        }

        button:active {
            background: #4ad;
        }

        #hall-of-shame {
            background: #1a0a0a;
            border: 1px solid #600;
            padding: 10px;
            margin-top: 20px;
            font-size: 10px;
            color: #f66;
            max-height: 200px;
            overflow-y: auto;
        }

        #hall-of-shame h3 {
            color: #f66;
            font-size: 11px;
            margin-bottom: 5px;
        }

        #hall-of-shame li {
            margin: 3px 0;
            padding-left: 10px;
            list-style-position: inside;
        }

        .metrics {
            background: #0a1a0a;
            border: 1px solid #060;
            padding: 10px;
            margin-top: 10px;
            font-size: 10px;
            color: #6f6;
        }

        .metrics span {
            display: block;
            margin: 2px 0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1>ðŸ§ª FloAng Morph Lab</h1>
        <p style="font-size: 10px; color: #666; margin-bottom: 20px;">
            Continuous vector-based morphing system
        </p>

        <h2>Current State</h2>
        <div class="param">
            <label>Sides: <span class="value" id="sides-value">3</span></label>
            <input type="range" id="sides" min="3" max="12" step="1" value="3">
        </div>
        <div class="param">
            <label>Flow: <span class="value" id="flow-value">-0.66</span></label>
            <input type="range" id="flow" min="-3" max="1" step="0.01" value="-0.66">
        </div>
        <div class="param">
            <label>Angle: <span class="value" id="angle-value">60Â°</span></label>
            <input type="range" id="angle" min="20" max="160" step="1" value="60">
        </div>

        <h2>Morph Parameters</h2>
        <div class="param">
            <label>Duration (ms): <span class="value" id="duration-value">3000</span></label>
            <input type="range" id="duration" min="500" max="10000" step="100" value="3000">
        </div>
        <div class="param">
            <label>Easing Power: <span class="value" id="easing-value">3</span></label>
            <input type="range" id="easing" min="1" max="5" step="0.1" value="3">
        </div>
        <div class="param">
            <label>Insertion Position: <span class="value" id="insertion-value">0.50</span></label>
            <input type="range" id="insertion" min="0" max="1" step="0.01" value="0.5">
        </div>
        <div class="param">
            <label>Emergence Speed: <span class="value" id="emergence-value">1.0</span></label>
            <input type="range" id="emergence" min="0.1" max="3" step="0.1" value="1.0">
        </div>
        <div class="param">
            <label>Symmetry Weight: <span class="value" id="symmetry-value">1.0</span></label>
            <input type="range" id="symmetry-weight" min="0" max="2" step="0.1" value="1.0">
        </div>

        <h2>Actions</h2>
        <button onclick="startMorph()">â–¶ Start Morph (n â†’ n+1)</button>
        <button onclick="resetState()">âŸ² Reset</button>
        <button onclick="addFailure()">ðŸ’€ Add Failure</button>

        <div class="metrics" id="metrics">
            <strong>Live Metrics:</strong>
            <span>Progress: <span id="progress-metric">0%</span></span>
            <span>Symmetry Score: <span id="symmetry-metric">-</span></span>
            <span>Anchor Count: <span id="anchor-metric">0</span></span>
        </div>

        <div id="hall-of-shame">
            <h3>ðŸ’€ Hall of Shame: What Didn't Workâ„¢</h3>
            <ul id="failure-list">
                <li>Linear interpolation of anchor positions - caused asymmetry collapse</li>
                <li>Equal spacing enforcement - fought with natural curve flow</li>
            </ul>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas" width="800" height="800"></canvas>
    </div>

    <script>
        /**
         * FloAng Morph Lab - Continuous Vector Animation System
         *
         * Core Concept: Instead of discretizing anchor points on a circle,
         * we represent them as continuous vectors with position, velocity,
         * and handle control points. This allows smooth morphing.
         */

        // ===== CORE DATA STRUCTURES =====

        /**
         * Anchor Point - Continuous vector representation
         */
        class AnchorPoint {
            constructor(x, y) {
                this.pos = { x, y };           // Position vector
                this.handleIn = { x: 0, y: 0 }; // Incoming handle (relative to pos)
                this.handleOut = { x: 0, y: 0 }; // Outgoing handle (relative to pos)
                this.velocity = { x: 0, y: 0 }; // For physics-based movement
                this.targetPos = null;          // Target position during morph
            }

            // Calculate absolute handle positions
            getHandleInAbs() {
                return {
                    x: this.pos.x + this.handleIn.x,
                    y: this.pos.y + this.handleIn.y
                };
            }

            getHandleOutAbs() {
                return {
                    x: this.pos.x + this.handleOut.x,
                    y: this.pos.y + this.handleOut.y
                };
            }

            // Set handles from flow and angle parameters
            setHandlesFromParams(flow, angle, nextAnchor) {
                const apex = GeometryUtils.calculateApex(this.pos, nextAnchor.pos, angle);
                const handles = GeometryUtils.calculateHandlesFromApex(
                    this.pos,
                    nextAnchor.pos,
                    apex,
                    flow
                );

                this.handleOut = handles.handleOut;
                nextAnchor.handleIn = handles.handleIn;
            }
        }

        /**
         * Shape - Collection of anchor points forming a closed path
         */
        class Shape {
            constructor(anchors = []) {
                this.anchors = anchors;
            }

            // Create n-sided polygon
            static createPolygon(sides, radius, centerX, centerY, rotation = 0) {
                const anchors = [];
                const angleStep = (2 * Math.PI) / sides;
                const rotRad = (rotation * Math.PI) / 180;

                for (let i = 0; i < sides; i++) {
                    const angle = rotRad + i * angleStep;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    anchors.push(new AnchorPoint(x, y));
                }

                return new Shape(anchors);
            }

            // Apply flow/angle parameters to all edges
            applyParams(flow, angle) {
                for (let i = 0; i < this.anchors.length; i++) {
                    const anchor = this.anchors[i];
                    const nextAnchor = this.anchors[(i + 1) % this.anchors.length];
                    anchor.setHandlesFromParams(flow, angle, nextAnchor);
                }
            }

            // Calculate comprehensive symmetry score
            calculateSymmetry() {
                if (this.anchors.length < 3) return 0;

                let totalError = 0;
                const n = this.anchors.length;

                // 1. Check edge length variance
                const edgeLengths = [];
                for (let i = 0; i < n; i++) {
                    const a1 = this.anchors[i];
                    const a2 = this.anchors[(i + 1) % n];
                    const dx = a2.pos.x - a1.pos.x;
                    const dy = a2.pos.y - a1.pos.y;
                    edgeLengths.push(Math.sqrt(dx * dx + dy * dy));
                }
                const meanEdgeLength = edgeLengths.reduce((a, b) => a + b, 0) / n;
                const edgeLengthVariance = edgeLengths.reduce((sum, len) =>
                    sum + Math.pow(len - meanEdgeLength, 2), 0) / n;
                totalError += edgeLengthVariance;

                // 2. Check angular distances from center
                const center = { x: 400, y: 400 }; // Known center
                const distances = [];
                for (let i = 0; i < n; i++) {
                    const dx = this.anchors[i].pos.x - center.x;
                    const dy = this.anchors[i].pos.y - center.y;
                    distances.push(Math.sqrt(dx * dx + dy * dy));
                }
                const meanDistance = distances.reduce((a, b) => a + b, 0) / n;
                const distanceVariance = distances.reduce((sum, dist) =>
                    sum + Math.pow(dist - meanDistance, 2), 0) / n;
                totalError += distanceVariance;

                // 3. Check handle magnitude variance (should be similar)
                const handleMagnitudes = [];
                for (let i = 0; i < n; i++) {
                    const anchor = this.anchors[i];
                    const magIn = Math.sqrt(anchor.handleIn.x ** 2 + anchor.handleIn.y ** 2);
                    const magOut = Math.sqrt(anchor.handleOut.x ** 2 + anchor.handleOut.y ** 2);
                    handleMagnitudes.push(magIn, magOut);
                }
                const meanHandleMag = handleMagnitudes.reduce((a, b) => a + b, 0) / handleMagnitudes.length;
                const handleVariance = handleMagnitudes.reduce((sum, mag) =>
                    sum + Math.pow(mag - meanHandleMag, 2), 0) / handleMagnitudes.length;
                totalError += handleVariance * 0.1; // Less weight on handles

                return totalError;
            }

            clone() {
                const newAnchors = this.anchors.map(a => {
                    const clone = new AnchorPoint(a.pos.x, a.pos.y);
                    clone.handleIn = { ...a.handleIn };
                    clone.handleOut = { ...a.handleOut };
                    return clone;
                });
                return new Shape(newAnchors);
            }
        }

        /**
         * Geometry Utilities - Reusable geometric calculations
         */
        class GeometryUtils {
            /**
             * Calculate orthogonal angle for n-sided polygon
             * This is the "perfect symmetry" angle where all edges are equal
             */
            static calculateOrthogonalAngle(sides) {
                return ((sides - 2) * 180) / sides;
            }

            /**
             * Calculate perpendicular vector to (dx, dy)
             * Returns normalized perpendicular with its length
             */
            static calculatePerpendicular(dx, dy) {
                const perpX = dy;
                const perpY = -dx;
                const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
                return { perpX, perpY, perpLength };
            }

            /**
             * Calculate apex point for bezier curve given two anchor positions,
             * an angle, and the edge vector between them
             */
            static calculateApex(p1, p2, angleDegrees) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const baseLength = Math.sqrt(dx * dx + dy * dy);

                const { perpX, perpY, perpLength } = this.calculatePerpendicular(dx, dy);

                const apexAngle = (angleDegrees * Math.PI) / 180;
                const height = (baseLength / 2) / Math.tan(apexAngle / 2);
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                const apexX = midX + (perpX / perpLength) * height;
                const apexY = midY + (perpY / perpLength) * height;

                return { x: apexX, y: apexY };
            }

            /**
             * Calculate handle vectors from an apex point for two anchors
             * Returns { handleOut, handleIn } suitable for assignment
             */
            static calculateHandlesFromApex(anchor1, anchor2, apex, flow) {
                return {
                    handleOut: {
                        x: (apex.x - anchor1.x) * flow,
                        y: (apex.y - anchor1.y) * flow
                    },
                    handleIn: {
                        x: (apex.x - anchor2.x) * flow,
                        y: (apex.y - anchor2.y) * flow
                    }
                };
            }

            /**
             * Evaluate cubic bezier curve at parameter t
             */
            static evaluateBezier(p0, cp1, cp2, p3, t) {
                const mt = 1 - t;
                const mt2 = mt * mt;
                const mt3 = mt2 * mt;
                const t2 = t * t;
                const t3 = t2 * t;

                return {
                    x: mt3 * p0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * p3.x,
                    y: mt3 * p0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * p3.y
                };
            }

            /**
             * Calculate tangent vector of cubic bezier at parameter t
             */
            static calculateBezierTangent(p0, cp1, cp2, p3, t) {
                const mt = 1 - t;
                const mt2 = mt * mt;
                const t2 = t * t;

                const dx = 3 * (mt2 * (cp1.x - p0.x) + 2 * mt * t * (cp2.x - cp1.x) + t2 * (p3.x - cp2.x));
                const dy = 3 * (mt2 * (cp1.y - p0.y) + 2 * mt * t * (cp2.y - cp1.y) + t2 * (p3.y - cp2.y));

                return { dx, dy, length: Math.sqrt(dx * dx + dy * dy) };
            }

            /**
             * Linearly interpolate between two vectors
             */
            static lerp(v1, v2, t) {
                return {
                    x: v1.x + (v2.x - v1.x) * t,
                    y: v1.y + (v2.y - v1.y) * t
                };
            }

            /**
             * Calculate distance between two points
             */
            static distance(p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            /**
             * Calculate magnitude of a vector
             */
            static magnitude(v) {
                return Math.sqrt(v.x * v.x + v.y * v.y);
            }
        }

        /**
         * MorphAnimation - Encapsulates the morph animation state and logic
         */
        class MorphAnimation {
            constructor() {
                this.active = false;
                this.startTime = 0;
                this.fromShape = null;
                this.toShape = null;
                this.progress = 0;
                this.params = null;
            }

            /**
             * Start a morph animation from one shape to another
             */
            start(fromShape, toShape, params) {
                this.fromShape = fromShape.clone();
                this.toShape = toShape;
                this.params = params;
                this.active = true;
                this.startTime = performance.now();
                this.progress = 0;
            }

            /**
             * Update the morph animation and return the current interpolated shape
             */
            update(timestamp) {
                if (!this.active) return null;

                const elapsed = timestamp - this.startTime;
                this.progress = Math.min(elapsed / this.params.duration, 1);
                const easedProgress = this._easeInOutCubic(this.progress, this.params.easingPower);

                const currentShape = this._interpolateShapes(this.fromShape, this.toShape, easedProgress);

                if (this.progress >= 1) {
                    this.active = false;
                }

                return currentShape;
            }

            /**
             * Check if animation is complete
             */
            isComplete() {
                return this.progress >= 1;
            }

            /**
             * Easing function
             */
            _easeInOutCubic(t, power) {
                return t < 0.5
                    ? Math.pow(2, power - 1) * Math.pow(t, power)
                    : 1 - Math.pow(-2 * t + 2, power) / 2;
            }

            /**
             * Main interpolation logic (extracted from lerpShapes)
             */
            _interpolateShapes(from, to, t) {
                const fromSides = from.anchors.length;
                const toSides = fromSides + 1;

                const fromOrthogonal = GeometryUtils.calculateOrthogonalAngle(fromSides);
                const toOrthogonal = GeometryUtils.calculateOrthogonalAngle(toSides);

                const result = from.clone();

                // STEP 1: Insert new anchor (if not already inserted)
                if (t > 0 && result.anchors.length === fromSides) {
                    this._insertNewAnchor(result, fromSides);
                }

                // STEP 2 & 3: Normalize positions and handles
                if (result.anchors.length === toSides) {
                    this._normalizeShape(result, to, fromOrthogonal, toOrthogonal, t, toSides);
                }

                return result;
            }

            /**
             * STEP 1: Insert new anchor on the bezier curve
             * FIXES BUG #2: Check bounds before accessing from.anchors
             */
            _insertNewAnchor(result, fromSides) {
                const lastAnchor = result.anchors[fromSides - 1];
                const firstAnchor = result.anchors[0];

                const p0 = lastAnchor.pos;
                const cp1 = lastAnchor.getHandleOutAbs();
                const cp2 = firstAnchor.getHandleInAbs();
                const p3 = firstAnchor.pos;

                const insertT = this.params.insertionPosition;
                const newPos = GeometryUtils.evaluateBezier(p0, cp1, cp2, p3, insertT);
                const newAnchor = new AnchorPoint(newPos.x, newPos.y);

                const tangent = GeometryUtils.calculateBezierTangent(p0, cp1, cp2, p3, insertT);
                const initialRatio = 0.2;
                const handleLength = tangent.length * insertT * initialRatio;

                if (tangent.length > 0) {
                    const normDx = tangent.dx / tangent.length;
                    const normDy = tangent.dy / tangent.length;

                    newAnchor.handleIn.x = -normDx * handleLength;
                    newAnchor.handleIn.y = -normDy * handleLength;
                    newAnchor.handleOut.x = normDx * handleLength;
                    newAnchor.handleOut.y = normDy * handleLength;
                } else {
                    newAnchor.handleIn = { x: 0, y: 0 };
                    newAnchor.handleOut = { x: 0, y: 0 };
                }

                result.anchors.push(newAnchor);

                // Store initial handle values for smooth interpolation
                // BUG FIX #2: Add bounds checking before storing
                const newAnchorIdx = result.anchors.length - 1;
                if (!this.fromShape.anchors[newAnchorIdx - 1]._storedHandleOut) {
                    this.fromShape.anchors[newAnchorIdx - 1]._storedHandleOut = {
                        x: result.anchors[newAnchorIdx - 1].handleOut.x,
                        y: result.anchors[newAnchorIdx - 1].handleOut.y
                    };
                }
                if (!this.fromShape.anchors[0]._storedHandleIn) {
                    this.fromShape.anchors[0]._storedHandleIn = {
                        x: result.anchors[0].handleIn.x,
                        y: result.anchors[0].handleIn.y
                    };
                }

                // Copy stored values to result
                result.anchors[newAnchorIdx - 1]._storedHandleOut = this.fromShape.anchors[newAnchorIdx - 1]._storedHandleOut;
                result.anchors[0]._storedHandleIn = this.fromShape.anchors[0]._storedHandleIn;
            }

            /**
             * STEP 2 & 3: Normalize shape positions and handles
             * FIXES BUGS #3 and #4: Ensure handleOut and handleIn are set for emerging anchor
             */
            _normalizeShape(result, to, fromOrthogonal, toOrthogonal, t, toSides) {
                const currentAngle = fromOrthogonal + (toOrthogonal - fromOrthogonal) * t;
                const newAnchorIdx = result.anchors.length - 1;

                // Move new anchor toward target position
                const newAnchor = result.anchors[newAnchorIdx];
                const targetAnchor = to.anchors[toSides - 1];
                newAnchor.pos = GeometryUtils.lerp(
                    newAnchor.pos,
                    targetAnchor.pos,
                    t * this.params.emergenceSpeed
                );

                // Normalize all anchor positions to maintain symmetry
                const radius = 250;
                const center = { x: 400, y: 400 };
                const angleStep = (2 * Math.PI) / toSides;

                for (let i = 0; i < result.anchors.length; i++) {
                    const targetAngle = i * angleStep;
                    const targetX = center.x + radius * Math.cos(targetAngle);
                    const targetY = center.y + radius * Math.sin(targetAngle);
                    const currentAnchor = result.anchors[i];
                    const normalizationStrength = t * this.params.symmetryWeight;

                    currentAnchor.pos = GeometryUtils.lerp(
                        currentAnchor.pos,
                        { x: targetX, y: targetY },
                        normalizationStrength
                    );
                }

                // Recalculate handles for all edges
                for (let i = 0; i < result.anchors.length; i++) {
                    const anchor = result.anchors[i];
                    const nextAnchor = result.anchors[(i + 1) % result.anchors.length];

                    const isEdgeBeforeEmerging = (i === newAnchorIdx - 1);
                    const isEdgeAfterEmerging = (i === newAnchorIdx);

                    const apex = GeometryUtils.calculateApex(anchor.pos, nextAnchor.pos, currentAngle);
                    const handles = GeometryUtils.calculateHandlesFromApex(
                        anchor.pos,
                        nextAnchor.pos,
                        apex,
                        this.params.flow
                    );

                    // FIX BUG #3: Ensure emerging anchor's handleOut is set
                    if (isEdgeBeforeEmerging && anchor._storedHandleOut) {
                        anchor.handleOut = GeometryUtils.lerp(
                            anchor._storedHandleOut,
                            handles.handleOut,
                            t
                        );
                    } else if (!isEdgeAfterEmerging) {
                        // Non-adjacent edges and emerging anchor itself: set directly
                        anchor.handleOut = handles.handleOut;
                    }

                    // FIX BUG #4: Ensure emerging anchor's handleIn is set
                    if (isEdgeAfterEmerging && nextAnchor._storedHandleIn) {
                        nextAnchor.handleIn = GeometryUtils.lerp(
                            nextAnchor._storedHandleIn,
                            handles.handleIn,
                            t
                        );
                    } else if (!isEdgeBeforeEmerging) {
                        // Non-adjacent edges and emerging anchor itself: set directly
                        nextAnchor.handleIn = handles.handleIn;
                    }
                }

                // STEP 3: Handle emerging anchor specially with tangent->orthogonal easing
                this._easeEmergingAnchorHandles(result, newAnchorIdx, currentAngle, t);
            }

            /**
             * STEP 3: Ease emerging anchor handles from tangent to orthogonal
             */
            _easeEmergingAnchorHandles(result, newAnchorIdx, currentAngle, t) {
                const emergingAnchor = result.anchors[newAnchorIdx];
                const lastAnchor = result.anchors[newAnchorIdx - 1];
                const firstAnchor = result.anchors[0];

                // Re-calculate initial tangent-based handles
                const p0 = lastAnchor.pos;
                const cp1Initial = {
                    x: p0.x + lastAnchor.handleOut.x,
                    y: p0.y + lastAnchor.handleOut.y
                };
                const cp2Initial = {
                    x: firstAnchor.pos.x + firstAnchor.handleIn.x,
                    y: firstAnchor.pos.y + firstAnchor.handleIn.y
                };
                const p3 = firstAnchor.pos;

                const insertT = this.params.insertionPosition;
                const tangent = GeometryUtils.calculateBezierTangent(p0, cp1Initial, cp2Initial, p3, insertT);

                let initialHandleIn = { x: 0, y: 0 };
                let initialHandleOut = { x: 0, y: 0 };

                if (tangent.length > 0) {
                    const normDx = tangent.dx / tangent.length;
                    const normDy = tangent.dy / tangent.length;
                    const initialRatio = 0.2;
                    const handleLength = tangent.length * insertT * initialRatio;

                    initialHandleIn.x = -normDx * handleLength;
                    initialHandleIn.y = -normDy * handleLength;
                    initialHandleOut.x = normDx * handleLength;
                    initialHandleOut.y = normDy * handleLength;
                }

                // Calculate target orthogonal handles
                const prevAnchor = result.anchors[newAnchorIdx - 1];
                const nextAnchor = result.anchors[0];

                const apexOut = GeometryUtils.calculateApex(emergingAnchor.pos, nextAnchor.pos, currentAngle);
                const apexIn = GeometryUtils.calculateApex(prevAnchor.pos, emergingAnchor.pos, currentAngle);

                const targetHandleOut = {
                    x: (apexOut.x - emergingAnchor.pos.x) * this.params.flow,
                    y: (apexOut.y - emergingAnchor.pos.y) * this.params.flow
                };
                const targetHandleIn = {
                    x: (apexIn.x - emergingAnchor.pos.x) * this.params.flow,
                    y: (apexIn.y - emergingAnchor.pos.y) * this.params.flow
                };

                // Interpolate from initial to target
                emergingAnchor.handleIn = GeometryUtils.lerp(initialHandleIn, targetHandleIn, t);
                emergingAnchor.handleOut = GeometryUtils.lerp(initialHandleOut, targetHandleOut, t);

                // Set anchor[0].handleIn to match same apex as emergingAnchor.handleOut
                const anchor0 = result.anchors[0];
                anchor0.handleIn.x = (apexOut.x - anchor0.pos.x) * this.params.flow;
                anchor0.handleIn.y = (apexOut.y - anchor0.pos.y) * this.params.flow;
            }
        }

        /**
         * Renderer - Handles all canvas drawing operations
         */
        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
            }

            /**
             * Clear the canvas
             */
            clear() {
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            /**
             * Draw a shape with its anchors and handles
             */
            drawShape(shape, options = {}) {
                if (!shape || shape.anchors.length < 2) return;

                const {
                    strokeColor = '#4682b4',
                    fillColor = 'rgba(135, 206, 235, 0.3)',
                    lineWidth = 2,
                    showAnchors = true,
                    showHandles = true
                } = options;

                this.ctx.strokeStyle = strokeColor;
                this.ctx.lineWidth = lineWidth;
                this.ctx.fillStyle = fillColor;

                // Draw the bezier path
                this.ctx.beginPath();
                const firstAnchor = shape.anchors[0];
                this.ctx.moveTo(firstAnchor.pos.x, firstAnchor.pos.y);

                for (let i = 0; i < shape.anchors.length; i++) {
                    const anchor = shape.anchors[i];
                    const nextAnchor = shape.anchors[(i + 1) % shape.anchors.length];

                    const cp1 = anchor.getHandleOutAbs();
                    const cp2 = nextAnchor.getHandleInAbs();

                    this.ctx.bezierCurveTo(
                        cp1.x, cp1.y,
                        cp2.x, cp2.y,
                        nextAnchor.pos.x, nextAnchor.pos.y
                    );
                }

                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();

                if (showAnchors) {
                    this._drawAnchors(shape.anchors, showHandles);
                }
            }

            /**
             * Draw anchor points and their handles
             */
            _drawAnchors(anchors, showHandles) {
                anchors.forEach(anchor => {
                    // Draw anchor point
                    this.ctx.fillStyle = '#ff00ff';
                    this.ctx.beginPath();
                    this.ctx.arc(anchor.pos.x, anchor.pos.y, 4, 0, Math.PI * 2);
                    this.ctx.fill();

                    if (showHandles) {
                        // Draw handle out
                        this.ctx.strokeStyle = '#f66';
                        this.ctx.lineWidth = 1;
                        const outAbs = anchor.getHandleOutAbs();
                        this.ctx.beginPath();
                        this.ctx.moveTo(anchor.pos.x, anchor.pos.y);
                        this.ctx.lineTo(outAbs.x, outAbs.y);
                        this.ctx.stroke();

                        this.ctx.fillStyle = '#f66';
                        this.ctx.beginPath();
                        this.ctx.arc(outAbs.x, outAbs.y, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
            }
        }

        /**
         * UIController - Manages UI interactions and parameter updates
         */
        class UIController {
            constructor(params, onParamChange) {
                this.params = params;
                this.onParamChange = onParamChange;
                this.setupListeners();
            }

            setupListeners() {
                // Sides slider
                document.getElementById('sides').addEventListener('input', (e) => {
                    this.params.sides = parseInt(e.target.value);
                    document.getElementById('sides-value').textContent = this.params.sides;
                    this.onParamChange('sides', this.params.sides);
                });

                // Flow slider
                document.getElementById('flow').addEventListener('input', (e) => {
                    this.params.flow = parseFloat(e.target.value);
                    document.getElementById('flow-value').textContent = this.params.flow.toFixed(2);
                    this.onParamChange('flow', this.params.flow);
                });

                // Angle slider
                document.getElementById('angle').addEventListener('input', (e) => {
                    this.params.angle = parseFloat(e.target.value);
                    document.getElementById('angle-value').textContent = this.params.angle + 'Â°';
                    this.onParamChange('angle', this.params.angle);
                });

                // Duration slider
                document.getElementById('duration').addEventListener('input', (e) => {
                    this.params.duration = parseInt(e.target.value);
                    document.getElementById('duration-value').textContent = this.params.duration;
                });

                // Easing slider
                document.getElementById('easing').addEventListener('input', (e) => {
                    this.params.easingPower = parseFloat(e.target.value);
                    document.getElementById('easing-value').textContent = this.params.easingPower.toFixed(1);
                });

                // Insertion position slider
                document.getElementById('insertion').addEventListener('input', (e) => {
                    this.params.insertionPosition = parseFloat(e.target.value);
                    document.getElementById('insertion-value').textContent = this.params.insertionPosition.toFixed(2);
                });

                // Emergence speed slider
                document.getElementById('emergence').addEventListener('input', (e) => {
                    this.params.emergenceSpeed = parseFloat(e.target.value);
                    document.getElementById('emergence-value').textContent = this.params.emergenceSpeed.toFixed(1);
                });

                // Symmetry weight slider
                document.getElementById('symmetry-weight').addEventListener('input', (e) => {
                    this.params.symmetryWeight = parseFloat(e.target.value);
                    document.getElementById('symmetry-value').textContent = this.params.symmetryWeight.toFixed(1);
                });
            }

            updateMetrics(progress, symmetry, anchorCount) {
                document.getElementById('progress-metric').textContent = (progress * 100).toFixed(1) + '%';
                document.getElementById('symmetry-metric').textContent = symmetry.toFixed(4);
                document.getElementById('anchor-metric').textContent = anchorCount;
            }
        }

        /**
         * SnapshotDebugger - Captures and displays shape snapshots for debugging
         */
        class SnapshotDebugger {
            constructor(params) {
                this.params = params;
                this.snapshots = {
                    before: null,
                    justAfter: null,
                    finished: null
                };
            }

            capture(shape, label) {
                if (!shape || shape.anchors.length < 2) return null;

                // Create SVG path data
                let pathData = `M ${shape.anchors[0].pos.x} ${shape.anchors[0].pos.y}`;

                for (let i = 0; i < shape.anchors.length; i++) {
                    const anchor = shape.anchors[i];
                    const nextAnchor = shape.anchors[(i + 1) % shape.anchors.length];
                    const cp1 = anchor.getHandleOutAbs();
                    const cp2 = nextAnchor.getHandleInAbs();

                    pathData += ` C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${nextAnchor.pos.x} ${nextAnchor.pos.y}`;
                }
                pathData += ' Z';

                // Calculate edge angles
                const edgeAngles = [];
                for (let i = 0; i < shape.anchors.length; i++) {
                    const anchor = shape.anchors[i];
                    const nextAnchor = shape.anchors[(i + 1) % shape.anchors.length];
                    const dx = nextAnchor.pos.x - anchor.pos.x;
                    const dy = nextAnchor.pos.y - anchor.pos.y;
                    const baseLength = Math.sqrt(dx * dx + dy * dy);

                    const cp1 = anchor.getHandleOutAbs();
                    const height = Math.abs((cp1.y - anchor.pos.y) * dx - (cp1.x - anchor.pos.x) * dy) / baseLength;
                    const angle = Math.atan((2 * height) / (baseLength / 2)) * (180 / Math.PI);
                    edgeAngles.push(angle.toFixed(2));
                }

                return {
                    label,
                    pathData,
                    anchors: shape.anchors.length,
                    symmetry: shape.calculateSymmetry().toFixed(4),
                    edgeAngles: edgeAngles.join(', '),
                    params: {
                        flow: this.params.flow.toFixed(2),
                        angle: this.params.angle.toFixed(0)
                    }
                };
            }

            display() {
                console.log('\n=== SNAPSHOT COMPARISON ===');
                console.log('BEFORE:', this.snapshots.before);
                console.log('JUST AFTER:', this.snapshots.justAfter);
                console.log('FINISHED:', this.snapshots.finished);

                // Create SVG comparison (using template literals for better readability)
                // Paths use absolute coordinates with center at (400,400), so we translate to offset them
                const svg = `
<svg width="1400" height="900" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1400 900">
    <rect width="1400" height="900" fill="#0a0a0a"/>

    <!-- Before -->
    <g transform="translate(-200, 50)">
        <path d="${this.snapshots.before?.pathData || ''}" fill="rgba(135,206,235,0.3)" stroke="#4682b4" stroke-width="2"/>
        <text x="400" y="50" fill="#fff" text-anchor="middle" font-size="14" font-weight="bold">BEFORE</text>
        <text x="400" y="70" fill="#aaa" text-anchor="middle" font-size="10">Anchors: ${this.snapshots.before?.anchors || 0}</text>
        <text x="400" y="85" fill="#aaa" text-anchor="middle" font-size="10">Symmetry: ${this.snapshots.before?.symmetry || 0}</text>
        <text x="400" y="100" fill="#aaa" text-anchor="middle" font-size="10">Flow: ${this.snapshots.before?.params.flow || 0}, Angle: ${this.snapshots.before?.params.angle || 0}Â°</text>
    </g>

    <!-- Just After -->
    <g transform="translate(200, 50)">
        <path d="${this.snapshots.justAfter?.pathData || ''}" fill="rgba(255,165,0,0.3)" stroke="#ff8c00" stroke-width="2"/>
        <text x="400" y="50" fill="#fff" text-anchor="middle" font-size="14" font-weight="bold">JUST AFTER START</text>
        <text x="400" y="70" fill="#aaa" text-anchor="middle" font-size="10">Anchors: ${this.snapshots.justAfter?.anchors || 0}</text>
        <text x="400" y="85" fill="#aaa" text-anchor="middle" font-size="10">Symmetry: ${this.snapshots.justAfter?.symmetry || 0}</text>
        <text x="400" y="100" fill="#aaa" text-anchor="middle" font-size="10">Flow: ${this.snapshots.justAfter?.params.flow || 0}, Angle: ${this.snapshots.justAfter?.params.angle || 0}Â°</text>
    </g>

    <!-- Finished -->
    <g transform="translate(600, 50)">
        <path d="${this.snapshots.finished?.pathData || ''}" fill="rgba(0,255,0,0.3)" stroke="#00ff00" stroke-width="2"/>
        <text x="400" y="50" fill="#fff" text-anchor="middle" font-size="14" font-weight="bold">FINISHED</text>
        <text x="400" y="70" fill="#aaa" text-anchor="middle" font-size="10">Anchors: ${this.snapshots.finished?.anchors || 0}</text>
        <text x="400" y="85" fill="#aaa" text-anchor="middle" font-size="10">Symmetry: ${this.snapshots.finished?.symmetry || 0}</text>
        <text x="400" y="100" fill="#aaa" text-anchor="middle" font-size="10">Flow: ${this.snapshots.finished?.params.flow || 0}, Angle: ${this.snapshots.finished?.params.angle || 0}Â°</text>
    </g>
</svg>`;

                console.log('SVG comparison:\n' + svg);

                // Save to file for viewing
                const blob = new Blob([svg], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'morph-snapshots.svg';
                a.click();
            }

            reset() {
                this.snapshots.justAfter = null;
                this.snapshots.finished = null;
            }
        }

        // ===== STATE =====

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let currentShape = null;
        let morphAnimation = new MorphAnimation();

        // Parameters (read from UI)
        const params = {
            sides: 3,
            flow: -0.66,
            angle: 60,
            duration: 3000,
            easingPower: 3,
            insertionPosition: 0.5,
            emergenceSpeed: 1.0,
            symmetryWeight: 1.0
        };

        // ===== INITIALIZATION =====

        function init() {
            // Create initial shape
            currentShape = Shape.createPolygon(params.sides, 250, 400, 400, 0);
            currentShape.applyParams(params.flow, params.angle);

            // Setup UI listeners
            setupUIListeners();

            // Start render loop
            requestAnimationFrame(render);
        }

        function setupUIListeners() {
            // Update parameters from UI
            document.getElementById('sides').addEventListener('input', (e) => {
                params.sides = parseInt(e.target.value);
                document.getElementById('sides-value').textContent = params.sides;
                if (!morphAnimation.active) {
                    currentShape = Shape.createPolygon(params.sides, 250, 400, 400, 0);
                    currentShape.applyParams(params.flow, params.angle);
                }
            });

            document.getElementById('flow').addEventListener('input', (e) => {
                params.flow = parseFloat(e.target.value);
                document.getElementById('flow-value').textContent = params.flow.toFixed(2);
                if (!morphAnimation.active) {
                    currentShape.applyParams(params.flow, params.angle);
                }
            });

            document.getElementById('angle').addEventListener('input', (e) => {
                params.angle = parseFloat(e.target.value);
                document.getElementById('angle-value').textContent = params.angle + 'Â°';
                if (!morphAnimation.active) {
                    currentShape.applyParams(params.flow, params.angle);
                }
            });

            document.getElementById('duration').addEventListener('input', (e) => {
                params.duration = parseInt(e.target.value);
                document.getElementById('duration-value').textContent = params.duration;
            });

            document.getElementById('easing').addEventListener('input', (e) => {
                params.easingPower = parseFloat(e.target.value);
                document.getElementById('easing-value').textContent = params.easingPower.toFixed(1);
            });

            document.getElementById('insertion').addEventListener('input', (e) => {
                params.insertionPosition = parseFloat(e.target.value);
                document.getElementById('insertion-value').textContent = params.insertionPosition.toFixed(2);
            });

            document.getElementById('emergence').addEventListener('input', (e) => {
                params.emergenceSpeed = parseFloat(e.target.value);
                document.getElementById('emergence-value').textContent = params.emergenceSpeed.toFixed(1);
            });

            document.getElementById('symmetry-weight').addEventListener('input', (e) => {
                params.symmetryWeight = parseFloat(e.target.value);
                document.getElementById('symmetry-value').textContent = params.symmetryWeight.toFixed(1);
            });
        }

        // ===== MORPH LOGIC =====

        // ===== SNAPSHOT DEBUGGING =====
        const snapshots = {
            before: null,
            justAfter: null,
            finished: null
        };

        function captureSnapshot(shape, label) {
            if (!shape || shape.anchors.length < 2) return null;

            // Create SVG path data
            let pathData = `M ${shape.anchors[0].pos.x} ${shape.anchors[0].pos.y}`;

            for (let i = 0; i < shape.anchors.length; i++) {
                const anchor = shape.anchors[i];
                const nextAnchor = shape.anchors[(i + 1) % shape.anchors.length];
                const cp1 = anchor.getHandleOutAbs();
                const cp2 = nextAnchor.getHandleInAbs();

                pathData += ` C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${nextAnchor.pos.x} ${nextAnchor.pos.y}`;
            }
            pathData += ' Z';

            // Capture relative handle vectors for each anchor
            const anchorData = [];
            for (let i = 0; i < shape.anchors.length; i++) {
                const anchor = shape.anchors[i];
                anchorData.push({
                    index: i,
                    pos: { x: anchor.pos.x.toFixed(2), y: anchor.pos.y.toFixed(2) },
                    handleIn: { x: anchor.handleIn.x.toFixed(4), y: anchor.handleIn.y.toFixed(4) },
                    handleOut: { x: anchor.handleOut.x.toFixed(4), y: anchor.handleOut.y.toFixed(4) }
                });
            }

            // Calculate edge angles
            const edgeAngles = [];
            for (let i = 0; i < shape.anchors.length; i++) {
                const anchor = shape.anchors[i];
                const nextAnchor = shape.anchors[(i + 1) % shape.anchors.length];
                const dx = nextAnchor.pos.x - anchor.pos.x;
                const dy = nextAnchor.pos.y - anchor.pos.y;
                const baseLength = Math.sqrt(dx * dx + dy * dy);

                const cp1 = anchor.getHandleOutAbs();
                const height = Math.abs((cp1.y - anchor.pos.y) * dx - (cp1.x - anchor.pos.x) * dy) / baseLength;
                const angle = Math.atan((2 * height) / (baseLength / 2)) * (180 / Math.PI);
                edgeAngles.push(angle.toFixed(2));
            }

            return {
                label,
                pathData,
                anchors: shape.anchors.length,
                symmetry: shape.calculateSymmetry().toFixed(4),
                edgeAngles: edgeAngles.join(', '),
                anchorData: anchorData,
                params: {
                    flow: params.flow.toFixed(2),
                    angle: params.angle.toFixed(0)
                }
            };
        }

        function displaySnapshots() {
            console.log('\n=== SNAPSHOT COMPARISON ===');
            console.log('BEFORE:', snapshots.before);
            console.log('JUST AFTER:', snapshots.justAfter);
            console.log('FINISHED:', snapshots.finished);

            // Create visual comparison with handle data
            // Paths use absolute coords with center at (400,400), so we translate to offset them
            const svg = `
<svg width="1400" height="900" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1400 900">
    <rect width="1400" height="900" fill="#0a0a0a"/>

    <!-- Before -->
    <g transform="translate(-200, 50)">
        <path d="${snapshots.before?.pathData || ''}" fill="rgba(135,206,235,0.3)" stroke="#4682b4" stroke-width="2"/>
        <text x="400" y="50" fill="#fff" text-anchor="middle" font-size="14" font-weight="bold">BEFORE</text>
        <text x="400" y="70" fill="#aaa" text-anchor="middle" font-size="10">Anchors: ${snapshots.before?.anchors || 0}</text>
        <text x="400" y="85" fill="#aaa" text-anchor="middle" font-size="10">Symmetry: ${snapshots.before?.symmetry || 0}</text>
        <text x="400" y="100" fill="#aaa" text-anchor="middle" font-size="10">Flow: ${snapshots.before?.params.flow || 0}, Angle: ${snapshots.before?.params.angle || 0}Â°</text>
        <text x="400" y="115" fill="#aaa" text-anchor="middle" font-size="9">Angles: ${snapshots.before?.edgeAngles || ''}</text>
    </g>

    <!-- Just After -->
    <g transform="translate(200, 50)">
        <path d="${snapshots.justAfter?.pathData || ''}" fill="rgba(255,165,0,0.3)" stroke="#ff8c00" stroke-width="2"/>
        <text x="400" y="50" fill="#fff" text-anchor="middle" font-size="14" font-weight="bold">JUST AFTER START</text>
        <text x="400" y="70" fill="#aaa" text-anchor="middle" font-size="10">Anchors: ${snapshots.justAfter?.anchors || 0}</text>
        <text x="400" y="85" fill="#aaa" text-anchor="middle" font-size="10">Symmetry: ${snapshots.justAfter?.symmetry || 0}</text>
        <text x="400" y="100" fill="#aaa" text-anchor="middle" font-size="10">Flow: ${snapshots.justAfter?.params.flow || 0}, Angle: ${snapshots.justAfter?.params.angle || 0}Â°</text>
        <text x="400" y="115" fill="#aaa" text-anchor="middle" font-size="9">Angles: ${snapshots.justAfter?.edgeAngles || ''}</text>
    </g>

    <!-- Finished -->
    <g transform="translate(600, 50)">
        <path d="${snapshots.finished?.pathData || ''}" fill="rgba(0,255,0,0.3)" stroke="#00ff00" stroke-width="2"/>
        <text x="400" y="50" fill="#fff" text-anchor="middle" font-size="14" font-weight="bold">FINISHED</text>
        <text x="400" y="70" fill="#aaa" text-anchor="middle" font-size="10">Anchors: ${snapshots.finished?.anchors || 0}</text>
        <text x="400" y="85" fill="#aaa" text-anchor="middle" font-size="10">Symmetry: ${snapshots.finished?.symmetry || 0}</text>
        <text x="400" y="100" fill="#aaa" text-anchor="middle" font-size="10">Flow: ${snapshots.finished?.params.flow || 0}, Angle: ${snapshots.finished?.params.angle || 0}Â°</text>
        <text x="400" y="115" fill="#aaa" text-anchor="middle" font-size="9">Angles: ${snapshots.finished?.edgeAngles || ''}</text>
    </g>
</svg>`;

            console.log('SVG comparison:\n' + svg);

            // Save to file for viewing
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'morph-snapshots.svg';
            a.click();
        }

        function startMorph() {
            if (morphAnimation.active) return;

            const fromSides = params.sides;
            const toSides = fromSides + 1;

            // CAPTURE SNAPSHOT: BEFORE
            snapshots.before = captureSnapshot(currentShape, 'BEFORE');

            // Create target shape with n+1 sides
            const toShape = Shape.createPolygon(toSides, 250, 400, 400, 0);
            toShape.applyParams(params.flow, params.angle);

            // Start morph animation
            morphAnimation.start(currentShape, toShape, params);

            // Reset snapshot flags
            snapshots.justAfter = null;
            snapshots.finished = null;

            console.log(`Starting morph: ${fromSides} â†’ ${toSides} sides`);
        }

        function updateMorph(timestamp) {
            if (!morphAnimation.active) return;

            // Update animation and get interpolated shape
            currentShape = morphAnimation.update(timestamp);

            // CAPTURE SNAPSHOT: JUST AFTER START (around 1-2% progress)
            if (!snapshots.justAfter && morphAnimation.progress > 0.01 && morphAnimation.progress < 0.03) {
                snapshots.justAfter = captureSnapshot(currentShape, 'JUST AFTER');
                console.log('Captured JUST AFTER snapshot at progress:', (morphAnimation.progress * 100).toFixed(1) + '%');
            }

            // Update metrics
            document.getElementById('progress-metric').textContent = (morphAnimation.progress * 100).toFixed(1) + '%';
            document.getElementById('symmetry-metric').textContent = currentShape.calculateSymmetry().toFixed(4);
            document.getElementById('anchor-metric').textContent = currentShape.anchors.length;

            // Check if complete
            if (morphAnimation.isComplete()) {
                // CAPTURE SNAPSHOT: FINISHED
                snapshots.finished = captureSnapshot(currentShape, 'FINISHED');
                console.log('Captured FINISHED snapshot');

                // Display all snapshots
                displaySnapshots();

                params.sides++;
                document.getElementById('sides').value = params.sides;
                document.getElementById('sides-value').textContent = params.sides;
                console.log('Morph complete');
            }
        }

        // lerpShapes function has been moved to MorphAnimation._interpolateShapes()
        // Legacy function removed - all morph logic is now in MorphAnimation class

        // Keeping this as a wrapper for backwards compatibility if needed

        // ===== RENDERING =====

        function render(timestamp) {
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update morph if active
            if (morphAnimation.active) {
                updateMorph(timestamp);
            }

            // Draw current shape
            if (currentShape) {
                drawShape(currentShape);
            }

            requestAnimationFrame(render);
        }

        function drawShape(shape) {
            if (shape.anchors.length < 2) return;

            ctx.strokeStyle = '#4682b4';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(135, 206, 235, 0.3)';

            // Draw the path
            ctx.beginPath();
            const firstAnchor = shape.anchors[0];
            ctx.moveTo(firstAnchor.pos.x, firstAnchor.pos.y);

            for (let i = 0; i < shape.anchors.length; i++) {
                const anchor = shape.anchors[i];
                const nextAnchor = shape.anchors[(i + 1) % shape.anchors.length];

                const cp1 = anchor.getHandleOutAbs();
                const cp2 = nextAnchor.getHandleInAbs();

                ctx.bezierCurveTo(
                    cp1.x, cp1.y,
                    cp2.x, cp2.y,
                    nextAnchor.pos.x, nextAnchor.pos.y
                );
            }

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw anchor points
            shape.anchors.forEach(anchor => {
                ctx.fillStyle = '#ff00ff';
                ctx.beginPath();
                ctx.arc(anchor.pos.x, anchor.pos.y, 4, 0, Math.PI * 2);
                ctx.fill();

                // Draw handles
                ctx.strokeStyle = '#f66';
                ctx.lineWidth = 1;
                const outAbs = anchor.getHandleOutAbs();
                ctx.beginPath();
                ctx.moveTo(anchor.pos.x, anchor.pos.y);
                ctx.lineTo(outAbs.x, outAbs.y);
                ctx.stroke();

                ctx.fillStyle = '#f66';
                ctx.beginPath();
                ctx.arc(outAbs.x, outAbs.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ===== UI ACTIONS =====

        function resetState() {
            morphAnimation.active = false;
            currentShape = Shape.createPolygon(params.sides, 250, 400, 400, 0);
            currentShape.applyParams(params.flow, params.angle);
        }

        function addFailure() {
            const failure = prompt('What didn\'t work?');
            if (failure) {
                const list = document.getElementById('failure-list');
                const li = document.createElement('li');
                li.textContent = failure;
                list.appendChild(li);
            }
        }

        // Start the lab!
        init();
    </script>
</body>
</html>
