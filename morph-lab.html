<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FloAng Morph Lab - Continuous Vector Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #e0e0e0;
            font-family: 'Monaco', monospace;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #controls {
            width: 350px;
            background: #1a1a1a;
            border-right: 2px solid #333;
            padding: 20px;
            overflow-y: auto;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        canvas {
            border: 1px solid #333;
            background: #0a0a0a;
        }

        h1 {
            color: #6cf;
            font-size: 18px;
            margin-bottom: 20px;
            border-bottom: 2px solid #6cf;
            padding-bottom: 10px;
        }

        h2 {
            color: #f6c;
            font-size: 14px;
            margin: 20px 0 10px 0;
        }

        .param {
            margin: 15px 0;
        }

        .param label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }

        .param input[type="range"] {
            width: 100%;
        }

        .param .value {
            color: #6cf;
            font-weight: bold;
            float: right;
        }

        button {
            background: #6cf;
            color: #0a0a0a;
            border: none;
            padding: 10px 20px;
            font-family: 'Monaco', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            margin: 5px 5px 5px 0;
            transition: background 0.2s;
        }

        button:hover {
            background: #8ef;
        }

        button:active {
            background: #4ad;
        }

        #hall-of-shame {
            background: #1a0a0a;
            border: 1px solid #600;
            padding: 10px;
            margin-top: 20px;
            font-size: 10px;
            color: #f66;
            max-height: 200px;
            overflow-y: auto;
        }

        #hall-of-shame h3 {
            color: #f66;
            font-size: 11px;
            margin-bottom: 5px;
        }

        #hall-of-shame li {
            margin: 3px 0;
            padding-left: 10px;
            list-style-position: inside;
        }

        .metrics {
            background: #0a1a0a;
            border: 1px solid #060;
            padding: 10px;
            margin-top: 10px;
            font-size: 10px;
            color: #6f6;
        }

        .metrics span {
            display: block;
            margin: 2px 0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1>ðŸ§ª FloAng Morph Lab</h1>
        <p style="font-size: 10px; color: #666; margin-bottom: 20px;">
            Continuous vector-based morphing system
        </p>

        <h2>Current State</h2>
        <div class="param">
            <label>Sides: <span class="value" id="sides-value">3</span></label>
            <input type="range" id="sides" min="3" max="12" step="1" value="3">
        </div>
        <div class="param">
            <label>Flow: <span class="value" id="flow-value">-0.66</span></label>
            <input type="range" id="flow" min="-3" max="1" step="0.01" value="-0.66">
        </div>
        <div class="param">
            <label>Angle: <span class="value" id="angle-value">60Â°</span></label>
            <input type="range" id="angle" min="20" max="160" step="1" value="60">
        </div>

        <h2>Morph Parameters</h2>
        <div class="param">
            <label>Duration (ms): <span class="value" id="duration-value">3000</span></label>
            <input type="range" id="duration" min="500" max="10000" step="100" value="3000">
        </div>
        <div class="param">
            <label>Easing Power: <span class="value" id="easing-value">3</span></label>
            <input type="range" id="easing" min="1" max="5" step="0.1" value="3">
        </div>
        <div class="param">
            <label>Insertion Position: <span class="value" id="insertion-value">0.50</span></label>
            <input type="range" id="insertion" min="0" max="1" step="0.01" value="0.5">
        </div>
        <div class="param">
            <label>Emergence Speed: <span class="value" id="emergence-value">1.0</span></label>
            <input type="range" id="emergence" min="0.1" max="3" step="0.1" value="1.0">
        </div>
        <div class="param">
            <label>Symmetry Weight: <span class="value" id="symmetry-value">1.0</span></label>
            <input type="range" id="symmetry-weight" min="0" max="2" step="0.1" value="1.0">
        </div>

        <h2>Actions</h2>
        <button onclick="startMorph()">â–¶ Start Morph (n â†’ n+1)</button>
        <button onclick="resetState()">âŸ² Reset</button>
        <button onclick="addFailure()">ðŸ’€ Add Failure</button>

        <div class="metrics" id="metrics">
            <strong>Live Metrics:</strong>
            <span>Progress: <span id="progress-metric">0%</span></span>
            <span>Symmetry Score: <span id="symmetry-metric">-</span></span>
            <span>Anchor Count: <span id="anchor-metric">0</span></span>
        </div>

        <div id="hall-of-shame">
            <h3>ðŸ’€ Hall of Shame: What Didn't Workâ„¢</h3>
            <ul id="failure-list">
                <li>Linear interpolation of anchor positions - caused asymmetry collapse</li>
                <li>Equal spacing enforcement - fought with natural curve flow</li>
            </ul>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas" width="800" height="800"></canvas>
    </div>

    <script>
        /**
         * FloAng Morph Lab - Continuous Vector Animation System
         *
         * Core Concept: Instead of discretizing anchor points on a circle,
         * we represent them as continuous vectors with position, velocity,
         * and handle control points. This allows smooth morphing.
         */

        // ===== CORE DATA STRUCTURES =====

        /**
         * Anchor Point - Continuous vector representation
         */
        class AnchorPoint {
            constructor(x, y) {
                this.pos = { x, y };           // Position vector
                this.handleIn = { x: 0, y: 0 }; // Incoming handle (relative to pos)
                this.handleOut = { x: 0, y: 0 }; // Outgoing handle (relative to pos)
                this.velocity = { x: 0, y: 0 }; // For physics-based movement
                this.targetPos = null;          // Target position during morph
            }

            // Calculate absolute handle positions
            getHandleInAbs() {
                return {
                    x: this.pos.x + this.handleIn.x,
                    y: this.pos.y + this.handleIn.y
                };
            }

            getHandleOutAbs() {
                return {
                    x: this.pos.x + this.handleOut.x,
                    y: this.pos.y + this.handleOut.y
                };
            }

            // Set handles from flow and angle parameters
            setHandlesFromParams(flow, angle, nextAnchor) {
                const dx = nextAnchor.pos.x - this.pos.x;
                const dy = nextAnchor.pos.y - this.pos.y;
                const baseLength = Math.sqrt(dx * dx + dy * dy);

                // Perpendicular vector
                const perpX = dy;
                const perpY = -dx;
                const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);

                // Apex point
                const apexAngle = (angle * Math.PI) / 180;
                const height = (baseLength / 2) / Math.tan(apexAngle / 2);
                const midX = (this.pos.x + nextAnchor.pos.x) / 2;
                const midY = (this.pos.y + nextAnchor.pos.y) / 2;
                const apexX = midX + (perpX / perpLength) * height;
                const apexY = midY + (perpY / perpLength) * height;

                // Set handles based on flow
                this.handleOut.x = (apexX - this.pos.x) * flow;
                this.handleOut.y = (apexY - this.pos.y) * flow;
                nextAnchor.handleIn.x = (apexX - nextAnchor.pos.x) * flow;
                nextAnchor.handleIn.y = (apexY - nextAnchor.pos.y) * flow;
            }
        }

        /**
         * Shape - Collection of anchor points forming a closed path
         */
        class Shape {
            constructor(anchors = []) {
                this.anchors = anchors;
            }

            // Create n-sided polygon
            static createPolygon(sides, radius, centerX, centerY, rotation = 0) {
                const anchors = [];
                const angleStep = (2 * Math.PI) / sides;
                const rotRad = (rotation * Math.PI) / 180;

                for (let i = 0; i < sides; i++) {
                    const angle = rotRad + i * angleStep;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    anchors.push(new AnchorPoint(x, y));
                }

                return new Shape(anchors);
            }

            // Apply flow/angle parameters to all edges
            applyParams(flow, angle) {
                for (let i = 0; i < this.anchors.length; i++) {
                    const anchor = this.anchors[i];
                    const nextAnchor = this.anchors[(i + 1) % this.anchors.length];
                    anchor.setHandlesFromParams(flow, angle, nextAnchor);
                }
            }

            // Calculate symmetry score
            calculateSymmetry() {
                if (this.anchors.length < 3) return 0;

                // Measure variance in edge lengths
                const edgeLengths = [];
                for (let i = 0; i < this.anchors.length; i++) {
                    const a1 = this.anchors[i];
                    const a2 = this.anchors[(i + 1) % this.anchors.length];
                    const dx = a2.pos.x - a1.pos.x;
                    const dy = a2.pos.y - a1.pos.y;
                    edgeLengths.push(Math.sqrt(dx * dx + dy * dy));
                }

                const mean = edgeLengths.reduce((a, b) => a + b, 0) / edgeLengths.length;
                const variance = edgeLengths.reduce((sum, len) => sum + Math.pow(len - mean, 2), 0) / edgeLengths.length;

                return variance;
            }

            clone() {
                const newAnchors = this.anchors.map(a => {
                    const clone = new AnchorPoint(a.pos.x, a.pos.y);
                    clone.handleIn = { ...a.handleIn };
                    clone.handleOut = { ...a.handleOut };
                    return clone;
                });
                return new Shape(newAnchors);
            }
        }

        // ===== STATE =====

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let currentShape = null;
        let morphState = {
            active: false,
            startTime: 0,
            fromShape: null,
            toShape: null,
            progress: 0
        };

        // Parameters (read from UI)
        const params = {
            sides: 3,
            flow: -0.66,
            angle: 60,
            duration: 3000,
            easingPower: 3,
            insertionPosition: 0.5,
            emergenceSpeed: 1.0,
            symmetryWeight: 1.0
        };

        // ===== INITIALIZATION =====

        function init() {
            // Create initial shape
            currentShape = Shape.createPolygon(params.sides, 250, 400, 400, 0);
            currentShape.applyParams(params.flow, params.angle);

            // Setup UI listeners
            setupUIListeners();

            // Start render loop
            requestAnimationFrame(render);
        }

        function setupUIListeners() {
            // Update parameters from UI
            document.getElementById('sides').addEventListener('input', (e) => {
                params.sides = parseInt(e.target.value);
                document.getElementById('sides-value').textContent = params.sides;
                if (!morphState.active) {
                    currentShape = Shape.createPolygon(params.sides, 250, 400, 400, 0);
                    currentShape.applyParams(params.flow, params.angle);
                }
            });

            document.getElementById('flow').addEventListener('input', (e) => {
                params.flow = parseFloat(e.target.value);
                document.getElementById('flow-value').textContent = params.flow.toFixed(2);
                if (!morphState.active) {
                    currentShape.applyParams(params.flow, params.angle);
                }
            });

            document.getElementById('angle').addEventListener('input', (e) => {
                params.angle = parseFloat(e.target.value);
                document.getElementById('angle-value').textContent = params.angle + 'Â°';
                if (!morphState.active) {
                    currentShape.applyParams(params.flow, params.angle);
                }
            });

            document.getElementById('duration').addEventListener('input', (e) => {
                params.duration = parseInt(e.target.value);
                document.getElementById('duration-value').textContent = params.duration;
            });

            document.getElementById('easing').addEventListener('input', (e) => {
                params.easingPower = parseFloat(e.target.value);
                document.getElementById('easing-value').textContent = params.easingPower.toFixed(1);
            });

            document.getElementById('insertion').addEventListener('input', (e) => {
                params.insertionPosition = parseFloat(e.target.value);
                document.getElementById('insertion-value').textContent = params.insertionPosition.toFixed(2);
            });

            document.getElementById('emergence').addEventListener('input', (e) => {
                params.emergenceSpeed = parseFloat(e.target.value);
                document.getElementById('emergence-value').textContent = params.emergenceSpeed.toFixed(1);
            });

            document.getElementById('symmetry-weight').addEventListener('input', (e) => {
                params.symmetryWeight = parseFloat(e.target.value);
                document.getElementById('symmetry-value').textContent = params.symmetryWeight.toFixed(1);
            });
        }

        // ===== MORPH LOGIC =====

        function startMorph() {
            if (morphState.active) return;

            const fromSides = params.sides;
            const toSides = fromSides + 1;

            // Clone current shape as starting point
            morphState.fromShape = currentShape.clone();

            // Create target shape with n+1 sides
            morphState.toShape = Shape.createPolygon(toSides, 250, 400, 400, 0);
            morphState.toShape.applyParams(params.flow, params.angle);

            // Start morph animation
            morphState.active = true;
            morphState.startTime = performance.now();
            morphState.progress = 0;

            console.log(`Starting morph: ${fromSides} â†’ ${toSides} sides`);
        }

        function updateMorph(timestamp) {
            if (!morphState.active) return;

            const elapsed = timestamp - morphState.startTime;
            morphState.progress = Math.min(elapsed / params.duration, 1);
            const easedProgress = easeInOutCubic(morphState.progress, params.easingPower);

            // TODO: Implement continuous morph algorithm here
            // For now, just lerp the shapes
            currentShape = lerpShapes(morphState.fromShape, morphState.toShape, easedProgress);

            // Update metrics
            document.getElementById('progress-metric').textContent = (morphState.progress * 100).toFixed(1) + '%';
            document.getElementById('symmetry-metric').textContent = currentShape.calculateSymmetry().toFixed(4);
            document.getElementById('anchor-metric').textContent = currentShape.anchors.length;

            // Check if complete
            if (morphState.progress >= 1) {
                morphState.active = false;
                params.sides++;
                document.getElementById('sides').value = params.sides;
                document.getElementById('sides-value').textContent = params.sides;
                console.log('Morph complete');
            }
        }

        /**
         * Calculate orthogonal angle for n-sided polygon
         * This is the "perfect symmetry" angle where all edges are equal
         */
        function calculateOrthogonalAngle(sides) {
            return ((sides - 2) * 180) / sides;
        }

        /**
         * Morph algorithm: Insert new anchor and normalize to orthogonality
         *
         * Steps:
         * 1. Insert new anchor between anchor[0] and anchor[-1]
         * 2. Gradually normalize all parameters to maintain orthogonality
         */
        function lerpShapes(from, to, t) {
            const fromSides = from.anchors.length;
            const toSides = fromSides + 1;

            // Calculate orthogonal angles
            const fromOrthogonal = calculateOrthogonalAngle(fromSides);
            const toOrthogonal = calculateOrthogonalAngle(toSides);

            // Create result shape starting from 'from'
            const result = from.clone();

            // STEP 1: Insert new anchor between anchor[0] and anchor[-1]
            if (t > 0 && result.anchors.length === fromSides) {
                const lastAnchor = result.anchors[fromSides - 1];
                const firstAnchor = result.anchors[0];

                // Calculate insertion position along the edge
                const insertT = params.insertionPosition;
                const newX = lastAnchor.pos.x + (firstAnchor.pos.x - lastAnchor.pos.x) * insertT;
                const newY = lastAnchor.pos.y + (firstAnchor.pos.y - lastAnchor.pos.y) * insertT;

                // Create new anchor at insertion point
                const newAnchor = new AnchorPoint(newX, newY);

                // Insert it at the end (between last and first when path closes)
                result.anchors.push(newAnchor);
            }

            // STEP 2: Gradually normalize all parameters
            if (result.anchors.length === toSides) {
                // Interpolate angle towards target orthogonal
                const currentAngle = fromOrthogonal + (toOrthogonal - fromOrthogonal) * t;

                // Move new anchor outward from edge to final position
                const newAnchor = result.anchors[result.anchors.length - 1];
                const targetAnchor = to.anchors[to.anchors.length - 1];

                // Lerp position towards target
                newAnchor.pos.x = newAnchor.pos.x + (targetAnchor.pos.x - newAnchor.pos.x) * t * params.emergenceSpeed;
                newAnchor.pos.y = newAnchor.pos.y + (targetAnchor.pos.y - newAnchor.pos.y) * t * params.emergenceSpeed;

                // Gradually adjust all anchor positions to maintain symmetry
                // Redistribute anchors evenly around the circle
                const radius = 250; // Same as initial creation
                const center = { x: 400, y: 400 };
                const angleStep = (2 * Math.PI) / toSides;

                for (let i = 0; i < result.anchors.length; i++) {
                    const targetAngle = i * angleStep;
                    const targetX = center.x + radius * Math.cos(targetAngle);
                    const targetY = center.y + radius * Math.sin(targetAngle);

                    const currentAnchor = result.anchors[i];

                    // Smoothly interpolate towards target position
                    // Use symmetry weight to control how aggressively we enforce symmetry
                    const normalizationStrength = t * params.symmetryWeight;
                    currentAnchor.pos.x = currentAnchor.pos.x + (targetX - currentAnchor.pos.x) * normalizationStrength;
                    currentAnchor.pos.y = currentAnchor.pos.y + (targetY - currentAnchor.pos.y) * normalizationStrength;
                }

                // Update all handles to maintain orthogonality
                result.applyParams(params.flow, currentAngle);
            }

            return result;
        }

        function easeInOutCubic(t, power) {
            return t < 0.5
                ? Math.pow(2, power - 1) * Math.pow(t, power)
                : 1 - Math.pow(-2 * t + 2, power) / 2;
        }

        // ===== RENDERING =====

        function render(timestamp) {
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update morph if active
            if (morphState.active) {
                updateMorph(timestamp);
            }

            // Draw current shape
            if (currentShape) {
                drawShape(currentShape);
            }

            requestAnimationFrame(render);
        }

        function drawShape(shape) {
            if (shape.anchors.length < 2) return;

            ctx.strokeStyle = '#4682b4';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(135, 206, 235, 0.3)';

            // Draw the path
            ctx.beginPath();
            const firstAnchor = shape.anchors[0];
            ctx.moveTo(firstAnchor.pos.x, firstAnchor.pos.y);

            for (let i = 0; i < shape.anchors.length; i++) {
                const anchor = shape.anchors[i];
                const nextAnchor = shape.anchors[(i + 1) % shape.anchors.length];

                const cp1 = anchor.getHandleOutAbs();
                const cp2 = nextAnchor.getHandleInAbs();

                ctx.bezierCurveTo(
                    cp1.x, cp1.y,
                    cp2.x, cp2.y,
                    nextAnchor.pos.x, nextAnchor.pos.y
                );
            }

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw anchor points
            shape.anchors.forEach(anchor => {
                ctx.fillStyle = '#ff00ff';
                ctx.beginPath();
                ctx.arc(anchor.pos.x, anchor.pos.y, 4, 0, Math.PI * 2);
                ctx.fill();

                // Draw handles
                ctx.strokeStyle = '#f66';
                ctx.lineWidth = 1;
                const outAbs = anchor.getHandleOutAbs();
                ctx.beginPath();
                ctx.moveTo(anchor.pos.x, anchor.pos.y);
                ctx.lineTo(outAbs.x, outAbs.y);
                ctx.stroke();

                ctx.fillStyle = '#f66';
                ctx.beginPath();
                ctx.arc(outAbs.x, outAbs.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ===== UI ACTIONS =====

        function resetState() {
            morphState.active = false;
            currentShape = Shape.createPolygon(params.sides, 250, 400, 400, 0);
            currentShape.applyParams(params.flow, params.angle);
        }

        function addFailure() {
            const failure = prompt('What didn\'t work?');
            if (failure) {
                const list = document.getElementById('failure-list');
                const li = document.createElement('li');
                li.textContent = failure;
                list.appendChild(li);
            }
        }

        // Start the lab!
        init();
    </script>
</body>
</html>
