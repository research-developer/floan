<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FloAng - Flowangle Animation Studio</title>
    <link rel="stylesheet" href="styles.css">
    <script src="geometric_analysis.js"></script>
    <script src="parameter_explorer.js"></script>
</head>
<body>
    <!-- Top Controls -->
    <div id="controls-panel">
        <h1 style="color: #6cf; font-size: 18px; margin: 0;">üåä FloAng</h1>

        <div class="divider"></div>

        <!-- Presets -->
        <button class="preset-btn" onclick="loadPreset('triquetra')">Triquetra</button>
        <button class="preset-btn" onclick="loadPreset('flower')">Flower</button>
        <button class="preset-btn" onclick="loadPreset('star')">Star</button>
        <button class="preset-btn" onclick="loadPreset('smooth')">Smooth</button>

        <div class="divider"></div>

        <!-- Main Controls -->
        <div class="control-group">
            <label class="control-label">Sides (n)</label>
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="sides" min="1" max="12" value="3" oninput="updateSidesAndAngleRange()">
                <span class="control-value" id="sides-value">3</span>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Flow</label>
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="flow-factor" min="-3" max="1" step="0.01" value="-0.66" oninput="updatePreview()">
                <span class="control-value" id="flow-value">-0.66</span>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Angle</label>
            <div style="display: flex; align-items: center; gap: 10px; position: relative;">
                <div style="position: relative; flex: 1;">
                    <input type="range" id="handle-angle" min="10" max="170" step="1" value="60" oninput="updateAngleSlider()" style="width: 100%;">
                    <div id="angle-center-tick" style="position: absolute; top: 50%; left: 50%; width: 2px; height: 20px; background: #6cf; transform: translate(-50%, -50%); pointer-events: none; z-index: 1;"></div>
                </div>
                <span class="control-value" id="handle-angle-value">60¬∞</span>
                <span class="control-value" id="orthogonal-indicator" style="color: #6cf; font-size: 11px; min-width: 60px;">(‚ä• 60¬∞)</span>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Spin</label>
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="rotation" min="0" max="360" step="1" value="0" oninput="updatePreview()">
                <span class="control-value" id="rotation-value">0¬∞</span>
            </div>
        </div>

        <button onclick="openExplorer()" style="background: #c6f; color: #000;">üîç Explore Parameter Space</button>

        <div class="divider"></div>

        <button class="share-btn" onclick="shareConfiguration()">Share Configuration</button>
        <button onclick="downloadSVG()" style="background: #66c; color: #fff;">Download SVG</button>
        <button onclick="downloadPNG()" style="background: #66c; color: #fff;">Download PNG</button>
    </div>

    <aside id="debug-sidebar">
        <h2>üîß Debug Menu</h2>
        <div class="sidebar-section">
            <h3>Rendering</h3>
            <label class="sidebar-toggle">
                <input type="checkbox" id="fill-container" onchange="toggleFillContainer()">
                <span>Fill Container</span>
            </label>
            <label class="sidebar-toggle">
                <input type="checkbox" id="show-guides" onchange="updatePreview()">
                <span>Show Guides</span>
            </label>
            <label class="sidebar-toggle">
                <input type="checkbox" id="show-analysis" onchange="updatePreview()">
                <span>Geometric Analysis</span>
            </label>
        </div>

        <div class="sidebar-section">
            <h3>Exploration</h3>
            <label class="sidebar-toggle">
                <input type="checkbox" id="pulse-curve-enabled" onchange="updatePulseAnimations()">
                <span>Smoothing Animation</span>
            </label>
            <button class="sidebar-btn" onclick="openExplorer()">üîç Explore Parameter Space</button>
            <button class="sidebar-btn" onclick="shareConfiguration()">Share Configuration</button>
            <button class="sidebar-btn" onclick="downloadSVG()">Download SVG</button>
            <button class="sidebar-btn" onclick="downloadPNG()">Download PNG</button>
        </div>
    </aside>

    <!-- Share notification -->
    <div id="share-notification">Link copied to clipboard!</div>

    <!-- Generic notification -->
    <div id="notification" class="notification"></div>

    <!-- Overlay for modal -->
    <div id="overlay" class="overlay" onclick="closeAllModals()"></div>
    <div id="explorer-overlay" class="overlay" onclick="closeExplorer()"></div>

    <!-- Constraint Manager Panel -->
    <div id="constraint-manager">
        <div class="manager-header">
            <div class="manager-title">Constraint Manager</div>
            <button class="close-btn" onclick="closeConstraintManager()">√ó</button>
        </div>
        <div class="manager-content">
            <!-- Statistics -->
            <div class="stats-container">
                <div class="stat-card">
                    <div class="stat-label">Total N Values</div>
                    <div class="stat-value" id="stat-n-values">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Constraints</div>
                    <div class="stat-value" id="stat-constraints">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Mode</div>
                    <div class="stat-value" id="stat-mode" style="font-size: 16px;">Normal</div>
                </div>
            </div>

            <!-- Constraints Table -->
            <div id="constraints-table-container"></div>

            <!-- Import Dialog -->
            <div class="import-dialog" id="import-dialog" style="display: none;">
                <h3 style="margin-bottom: 10px; color: #6cf;">Import Constraints</h3>
                <textarea id="import-textarea" placeholder="Paste JSON constraints here..."></textarea>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button onclick="importFromTextarea()">Import JSON</button>
                    <button class="preset-btn" onclick="toggleImportDialog()">Cancel</button>
                </div>
            </div>
        </div>
        <div class="manager-actions">
            <button onclick="exportConstraints()">Export to Clipboard</button>
            <button onclick="toggleImportDialog()">Import from JSON</button>
            <button onclick="importFromClipboard()">Import from Clipboard</button>
            <button class="preset-btn" onclick="clearAllConstraints()">Clear All</button>
            <button class="preset-btn" style="background: #c44; color: white;" onclick="resetConstraints()">Reset to Defaults</button>
        </div>
    </div>

    <!-- Parameter Space Explorer Panel -->
    <div id="parameter-explorer" style="display: none;">
        <div class="manager-header">
            <div class="manager-title">üîç Parameter Space Explorer</div>
            <button class="close-btn" onclick="closeExplorer()">√ó</button>
        </div>
        <div class="manager-content">
            <!-- Exploration Controls -->
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="color: #6cf; margin-bottom: 15px;">Exploration Settings</h3>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                    <div class="control-group">
                        <label class="control-label">Current n (sides)</label>
                        <input type="number" id="explore-n" min="1" max="12" value="3" style="width: 100%;">
                    </div>
                    <div class="control-group">
                        <label class="control-label">Handle Angle Step</label>
                        <input type="number" id="explore-angle-step" min="1" max="20" value="5" style="width: 100%;">
                    </div>
                    <div class="control-group">
                        <label class="control-label">Flow Step</label>
                        <input type="number" id="explore-curve-step" min="0.05" max="0.5" step="0.05" value="0.1" style="width: 100%;">
                    </div>
                    <div class="control-group">
                        <label class="control-label">Resolution</label>
                        <select id="explore-resolution" style="width: 100%;">
                            <option value="coarse">Coarse (Fast)</option>
                            <option value="medium" selected>Medium</option>
                            <option value="fine">Fine (Slow)</option>
                        </select>
                    </div>
                </div>
                <button onclick="startExploration()" style="width: 100%; margin-top: 15px; padding: 12px; font-size: 14px;">
                    üöÄ Start Exploration
                </button>
                <div id="exploration-progress" style="display: none; margin-top: 15px; padding: 10px; background: #1a1a1a; border-radius: 4px; color: #6cf; text-align: center;">
                    Exploring...
                </div>
            </div>

            <!-- Results Section -->
            <div id="exploration-results" style="display: none;">
                <h3 style="color: #6cf; margin-bottom: 15px;">Discoveries</h3>

                <!-- Archetypes Grid -->
                <div class="stats-container" style="margin-bottom: 20px;">
                    <div class="stat-card" style="cursor: pointer;" onclick="showArchetype('fractalBloom')">
                        <div class="stat-label">Fractal Bloom</div>
                        <div class="stat-value" id="archetype-fractalBloom-count">0</div>
                    </div>
                    <div class="stat-card" style="cursor: pointer;" onclick="showArchetype('gridAligned')">
                        <div class="stat-label">Grid Aligned</div>
                        <div class="stat-value" id="archetype-gridAligned-count">0</div>
                    </div>
                    <div class="stat-card" style="cursor: pointer;" onclick="showArchetype('petalDominant')">
                        <div class="stat-label">Petal Dominant</div>
                        <div class="stat-value" id="archetype-petalDominant-count">0</div>
                    </div>
                    <div class="stat-card" style="cursor: pointer;" onclick="showArchetype('roundTransition')">
                        <div class="stat-label">Round Transition</div>
                        <div class="stat-value" id="archetype-roundTransition-count">0</div>
                    </div>
                </div>

                <!-- Configuration Browser -->
                <div id="config-browser" style="background: #2a2a2a; padding: 15px; border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h4 style="color: #6cf; margin: 0;">Configuration Browser</h4>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="prevConfig()" style="padding: 5px 10px;">‚óÄ Prev</button>
                            <span id="config-counter" style="color: #e0e0e0;">0 / 0</span>
                            <button onclick="nextConfig()" style="padding: 5px 10px;">Next ‚ñ∂</button>
                        </div>
                    </div>

                    <div id="config-details" style="background: #1a1a1a; padding: 15px; border-radius: 4px; min-height: 200px;">
                        <p style="color: #888; text-align: center;">No configuration selected</p>
                    </div>

                    <button onclick="loadSelectedConfig()" style="width: 100%; margin-top: 15px;">
                        Load This Configuration
                    </button>
                </div>

                <!-- Export Button -->
                <button onclick="exportExploration()" style="width: 100%; margin-top: 15px; background: #4a4;">
                    üíæ Export Discoveries (JSON)
                </button>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div id="main-content">
        <div id="canvas-area">
            <div id="svg-preview"></div>
            <div id="keyboard-hint" class="keyboard-hint"></div>

            <!-- Keyboard Shortcuts Help -->
            <div class="keyboard-shortcuts collapsed" id="keyboard-shortcuts">
                <h4 onclick="toggleKeyboardShortcuts()">‚å®Ô∏è</h4>
                <div class="shortcuts-content">
                    <div class="shortcut"><span class="key">‚Üë‚Üì</span> <span>Flow</span></div>
                    <div class="shortcut"><span class="key">‚Üê‚Üí</span> <span>Angle</span></div>
                    <div class="shortcut"><span class="key">, .</span> <span>Sides</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pulse Animation Controls -->
    <div id="pulse-controls">
        <!-- Flow Pulse -->
        <div class="pulse-param" id="pulse-curve-param">
            <div class="pulse-header">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: bold;">
                    <input type="checkbox" id="pulse-curve-enabled" onchange="updatePulseAnimations()">
                    <span>Flow Pulse</span>
                </label>
            </div>
            <div class="pulse-controls-row">
                <div class="control-group">
                    <label class="control-label">Range (¬±)</label>
                    <input type="range" id="pulse-curve-range" min="0.1" max="2" step="0.1" value="0.5" onchange="updatePulseAnimations()">
                    <span class="control-value" id="pulse-curve-range-value">0.5</span>
                </div>
                <div class="control-group">
                    <label class="control-label">Speed</label>
                    <input type="range" id="pulse-curve-speed" min="0.5" max="5" step="0.1" value="2" onchange="updatePulseAnimations()">
                    <span class="control-value" id="pulse-curve-speed-value">2x</span>
                </div>
                <div class="control-group">
                    <label class="control-label">Easing</label>
                    <select id="pulse-curve-easing" onchange="updatePulseAnimations()">
                        <option value="linear">Linear</option>
                        <option value="easeInOut" selected>Ease In-Out</option>
                        <option value="easeIn">Ease In</option>
                        <option value="easeOut">Ease Out</option>
                        <option value="bounce">Bounce</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Handle Angle Pulse -->
        <div class="pulse-param" id="pulse-angle-param">
            <div class="pulse-header">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: bold;">
                    <input type="checkbox" id="pulse-angle-enabled" onchange="updatePulseAnimations()">
                    <span>Handle Angle Pulse</span>
                </label>
            </div>
            <div class="pulse-controls-row">
                <div class="control-group">
                    <label class="control-label">Range (¬±¬∞)</label>
                    <input type="range" id="pulse-angle-range" min="5" max="40" step="1" value="20" onchange="updatePulseAnimations()">
                    <span class="control-value" id="pulse-angle-range-value">20¬∞</span>
                </div>
                <div class="control-group">
                    <label class="control-label">Speed</label>
                    <input type="range" id="pulse-angle-speed" min="0.5" max="5" step="0.1" value="1.5" onchange="updatePulseAnimations()">
                    <span class="control-value" id="pulse-angle-speed-value">1.5x</span>
                </div>
                <div class="control-group">
                    <label class="control-label">Easing</label>
                    <select id="pulse-angle-easing" onchange="updatePulseAnimations()">
                        <option value="linear">Linear</option>
                        <option value="easeInOut" selected>Ease In-Out</option>
                        <option value="easeIn">Ease In</option>
                        <option value="easeOut">Ease Out</option>
                        <option value="bounce">Bounce</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Rotation Pulse -->
        <div class="pulse-param" id="pulse-rotation-param">
            <div class="pulse-header">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: bold;">
                    <input type="checkbox" id="pulse-rotation-enabled" onchange="updatePulseAnimations()">
                    <span>Rotation Pulse</span>
                </label>
            </div>
            <div class="pulse-controls-row">
                <div class="control-group">
                    <label class="control-label">Range (¬±¬∞)</label>
                    <input type="range" id="pulse-rotation-range" min="10" max="180" step="5" value="90" onchange="updatePulseAnimations()">
                    <span class="control-value" id="pulse-rotation-range-value">90¬∞</span>
                </div>
                <div class="control-group">
                    <label class="control-label">Speed</label>
                    <input type="range" id="pulse-rotation-speed" min="0.5" max="5" step="0.1" value="1" onchange="updatePulseAnimations()">
                    <span class="control-value" id="pulse-rotation-speed-value">1x</span>
                </div>
                <div class="control-group">
                    <label class="control-label">Easing</label>
                    <select id="pulse-rotation-easing" onchange="updatePulseAnimations()">
                        <option value="linear">Linear</option>
                        <option value="easeInOut" selected>Ease In-Out</option>
                        <option value="easeIn">Ease In</option>
                        <option value="easeOut">Ease Out</option>
                        <option value="bounce">Bounce</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <!-- Timeline -->
    <div id="timeline" class="discoveries-only">
        <div id="discoveries-tab" class="timeline-tab-content active">
            <div id="timeline-header">
                <div class="animation-controls" style="width: 100%;">
                    <div style="display: flex; align-items: center; gap: 15px; flex: 1;">
                        <span style="font-weight: bold; color: #6cf;">Notable Configurations for n=<span id="discoveries-n-value">3</span></span>
                        <button onclick="refreshDiscoveries()" style="padding: 6px 12px; font-size: 11px;">
                            üîÑ Refresh
                        </button>
                        <div id="discoveries-status" style="color: #888; font-size: 11px; flex: 1; text-align: right;">
                            Click a configuration to load it
                        </div>
                    </div>
                </div>
            </div>
            <div id="discoveries-container" style="display: flex; gap: 10px; padding: 10px 20px; overflow-x: auto; align-items: center; flex: 1;">
                <div style="width: 100%; text-align: center; color: #888; padding: 40px;">
                    Loading discoveries...
                </div>
            </div>
        </div>
    </div>

    <script>
        // State
        let keyframes = [];
        let activeKeyframeIndex = -1;
        let pulseAnimations = {};
        let pulseStartTime = 0;
        let keyframeAnimation = null;
        let isPlaying = false;
        let playStartTime = 0;

        // Constraint Manager
        let constraintManager = null;
        let feedbackMode = false;

        // Geometric Analyzer
        let geometricAnalyzer = new GeometricAnalyzer();
        let analysisResults = null;

        // Parameter Space Explorer
        let parameterExplorer = new ParameterSpaceExplorer(geometricAnalyzer);
        let currentDiscoveries = null;
        let currentConfigList = [];
        let currentConfigIndex = 0;
        let discoveriesCache = new Map(); // Cache discoveries by n-value
        let isExploringForDiscoveries = false;

        // Parameter mapping for constraint system
        const paramMap = {
            'flowFactor': { id: 'flow-factor', display: 'Flow', unit: '', decimals: 2 },
            'handleAngle': { id: 'handle-angle', display: 'Handle Angle', unit: '¬∞', decimals: 0 },
            'rotation': { id: 'rotation', display: 'Rotation', unit: '¬∞', decimals: 0 }
        };

        // Easing functions
        const easingFunctions = {
            linear: t => t,
            easeInOut: t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
            easeIn: t => t * t,
            easeOut: t => 1 - (1 - t) * (1 - t),
            bounce: t => {
                const n1 = 7.5625;
                const d1 = 2.75;
                if (t < 1 / d1) return n1 * t * t;
                if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
                if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
                return n1 * (t -= 2.625 / d1) * t + 0.984375;
            }
        };

        // LocalStorage functions
        function saveToLocalStorage() {
            try {
                const state = {
                    sides: parseInt(document.getElementById('sides').value),
                    flowFactor: parseFloat(document.getElementById('flow-factor').value),
                    handleAngle: parseFloat(document.getElementById('handle-angle').value),
                    rotation: parseFloat(document.getElementById('rotation').value),
                    strokeWidth: parseFloat(document.getElementById('stroke-width').value),
                    showGuides: document.getElementById('show-guides').checked,
                    showAnalysis: document.getElementById('show-analysis').checked,
                    timestamp: Date.now()
                };
                localStorage.setItem('floang_state', JSON.stringify(state));
            } catch (e) {
                console.warn('Could not save to localStorage:', e);
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('floang_state');
                if (saved) {
                    const state = JSON.parse(saved);
                    document.getElementById('sides').value = state.sides || 3;
                    document.getElementById('flow-factor').value = state.flowFactor || -0.66;
                    document.getElementById('handle-angle').value = state.handleAngle || 60;
                    document.getElementById('rotation').value = state.rotation || 0;
                    if (state.strokeWidth) document.getElementById('stroke-width').value = state.strokeWidth;
                    if (state.showGuides !== undefined) document.getElementById('show-guides').checked = state.showGuides;
                    if (state.showAnalysis !== undefined) document.getElementById('show-analysis').checked = state.showAnalysis;
                    return true;
                }
            } catch (e) {
                console.warn('Could not load from localStorage:', e);
            }
            return false;
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize constraint manager if available
            if (typeof initConstraintManager === 'function') {
                try {
                    initConstraintManager();
                } catch (e) {
                    console.warn('Constraint manager not available:', e);
                }
            }

            // Load state priority: URL params > localStorage > defaults
            const hasURLParams = await loadFromURL(); // Load from URL first if parameters exist
            if (!hasURLParams) {
                const hasLocalStorage = loadFromLocalStorage(); // If no URL params, try localStorage
                if (!hasLocalStorage) {
                    loadDefaultConfig(); // If no saved state, load default
                }
            }

            // Initialize angle slider range based on loaded sides value
            updateSidesAndAngleRange();
            updatePulseAnimations();
        });

        function toggleFillContainer() {
            const fillContainer = document.getElementById('fill-container').checked;
            const svgElement = document.querySelector('#svg-preview svg');
            if (svgElement) {
                if (fillContainer) {
                    svgElement.classList.add('fill-container');
                    svgElement.setAttribute('preserveAspectRatio', 'none');
                } else {
                    svgElement.classList.remove('fill-container');
                    svgElement.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                }
            }
        }

        // Update ranges when n changes
        document.getElementById('sides').addEventListener('input', function() {
            if (constraintManager) {
                updateSliderRanges(false);
            }
        });

        function getCurrentState() {
            return {
                sides: parseInt(document.getElementById('sides').value),
                flowFactor: parseFloat(document.getElementById('flow-factor').value),
                handleAngle: parseFloat(document.getElementById('handle-angle').value),
                rotation: parseFloat(document.getElementById('rotation').value),
                showGuides: document.getElementById('show-guides').checked,
                fillContainer: document.getElementById('fill-container').checked,
                pulseSettings: {
                    curve: {
                        enabled: document.getElementById('pulse-curve-enabled').checked,
                        range: parseFloat(document.getElementById('pulse-curve-range').value),
                        speed: parseFloat(document.getElementById('pulse-curve-speed').value),
                        easing: document.getElementById('pulse-curve-easing').value
                    },
                    angle: {
                        enabled: document.getElementById('pulse-angle-enabled').checked,
                        range: parseFloat(document.getElementById('pulse-angle-range').value),
                        speed: parseFloat(document.getElementById('pulse-angle-speed').value),
                        easing: document.getElementById('pulse-angle-easing').value
                    },
                    rotation: {
                        enabled: document.getElementById('pulse-rotation-enabled').checked,
                        range: parseFloat(document.getElementById('pulse-rotation-range').value),
                        speed: parseFloat(document.getElementById('pulse-rotation-speed').value),
                        easing: document.getElementById('pulse-rotation-easing').value
                    }
                }
            };
        }

        function applyState(state) {
            document.getElementById('sides').value = state.sides;
            document.getElementById('flow-factor').value = state.flowFactor;
            document.getElementById('handle-angle').value = state.handleAngle;
            document.getElementById('rotation').value = state.rotation;
            document.getElementById('show-guides').checked = state.showGuides;
            document.getElementById('fill-container').checked = state.fillContainer || false;

            // Apply pulse settings if present
            if (state.pulseSettings) {
                const ps = state.pulseSettings;

                // Curve pulse
                if (ps.curve) {
                    document.getElementById('pulse-curve-enabled').checked = ps.curve.enabled;
                    document.getElementById('pulse-curve-range').value = ps.curve.range;
                    document.getElementById('pulse-curve-speed').value = ps.curve.speed;
                    document.getElementById('pulse-curve-easing').value = ps.curve.easing;
                }

                // Angle pulse
                if (ps.angle) {
                    document.getElementById('pulse-angle-enabled').checked = ps.angle.enabled;
                    document.getElementById('pulse-angle-range').value = ps.angle.range;
                    document.getElementById('pulse-angle-speed').value = ps.angle.speed;
                    document.getElementById('pulse-angle-easing').value = ps.angle.easing;
                }

                // Rotation pulse
                if (ps.rotation) {
                    document.getElementById('pulse-rotation-enabled').checked = ps.rotation.enabled;
                    document.getElementById('pulse-rotation-range').value = ps.rotation.range;
                    document.getElementById('pulse-rotation-speed').value = ps.rotation.speed;
                    document.getElementById('pulse-rotation-easing').value = ps.rotation.easing;
                }

                // Update pulse animations to match restored state
                updatePulseAnimations();
            }

            updatePreview();
        }

        function updateSidesAndAngleRange() {
            const n = parseInt(document.getElementById('sides').value);

            // Calculate orthogonal angle using interior angle formula: (n - 2) √ó 180 / n
            const orthogonalAngle = (n - 2) * 180 / n;

            // Set slider range centered on orthogonal angle (¬±80¬∞ range)
            const range = 80;
            const minAngle = Math.max(10, orthogonalAngle - range);
            const maxAngle = Math.min(170, orthogonalAngle + range);

            const angleSlider = document.getElementById('handle-angle');
            angleSlider.min = minAngle;
            angleSlider.max = maxAngle;

            // If current angle is outside new range, set to orthogonal
            const currentAngle = parseFloat(angleSlider.value);
            if (currentAngle < minAngle || currentAngle > maxAngle) {
                angleSlider.value = orthogonalAngle;
            }

            // Update orthogonal indicator
            document.getElementById('orthogonal-indicator').textContent = `(‚ä• ${orthogonalAngle.toFixed(1)}¬∞)`;

            // Update the UI
            updateAngleSlider();
        }

        function updateAngleSlider() {
            const n = parseInt(document.getElementById('sides').value);
            const orthogonalAngle = (n - 2) * 180 / n;
            const currentAngle = parseFloat(document.getElementById('handle-angle').value);

            const angleSlider = document.getElementById('handle-angle');

            // Check if we're at orthogonal angle (within 0.5¬∞ tolerance)
            const isOrthogonal = Math.abs(currentAngle - orthogonalAngle) < 0.5;

            // Apply green styling when at orthogonal
            if (isOrthogonal) {
                angleSlider.style.accentColor = '#0f0';
            } else {
                angleSlider.style.accentColor = '';
            }

            // Update display value
            document.getElementById('handle-angle-value').textContent = currentAngle.toFixed(0) + '¬∞';

            // Update sides value display
            document.getElementById('sides-value').textContent = n;

            // Trigger preview update
            updatePreview();
        }

        function updatePreview() {
            const state = getCurrentState();

            // Update value displays
            document.getElementById('sides-value').textContent = state.sides;
            document.getElementById('flow-value').textContent = state.flowFactor.toFixed(2);
            document.getElementById('handle-angle-value').textContent = state.handleAngle + '¬∞';
            document.getElementById('rotation-value').textContent = state.rotation + '¬∞';

            // Update pulse control values
            document.getElementById('pulse-curve-range-value').textContent = document.getElementById('pulse-curve-range').value;
            document.getElementById('pulse-curve-speed-value').textContent = document.getElementById('pulse-curve-speed').value + 'x';
            document.getElementById('pulse-angle-range-value').textContent = document.getElementById('pulse-angle-range').value + '¬∞';
            document.getElementById('pulse-angle-speed-value').textContent = document.getElementById('pulse-angle-speed').value + 'x';
            document.getElementById('pulse-rotation-range-value').textContent = document.getElementById('pulse-rotation-range').value + '¬∞';
            document.getElementById('pulse-rotation-speed-value').textContent = document.getElementById('pulse-rotation-speed').value + 'x';

            document.getElementById('frame-length-value').textContent = document.getElementById('frame-length').value;
            document.getElementById('transition-value').textContent = document.getElementById('transition-time').value;

            // Generate SVG
            let svg = generateFlowAngle(state);

            // Add geometric analysis overlay if enabled
            if (document.getElementById('show-analysis').checked) {
                svg = addGeometricAnalysisOverlay(svg, state);
            }

            document.getElementById('svg-preview').innerHTML = svg;

            // Apply fill container setting
            toggleFillContainer();

            // Update active keyframe if exists
            if (activeKeyframeIndex >= 0 && !isPlaying) {
                keyframes[activeKeyframeIndex] = state;
                updateKeyframeDisplay();
            }

            // Save to localStorage
            saveToLocalStorage();
        }

        /**
         * Add geometric analysis visualization overlay
         */
        function addGeometricAnalysisOverlay(svgString, state) {
            // Parse the SVG string
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
            const svgElement = svgDoc.querySelector('svg');

            // Run geometric analysis
            analysisResults = geometricAnalyzer.analyzeFlowAngle(state, 600); // TODO: Make size dynamic based on container width

            let overlayShapes = '';

            // Visualize intersections
            analysisResults.intersections.forEach((intersection, i) => {
                overlayShapes += `<circle cx="${intersection.x}" cy="${intersection.y}" r="4" fill="#ff00ff" stroke="#fff" stroke-width="1" opacity="0.8"/>`;
                overlayShapes += `<text x="${intersection.x + 8}" y="${intersection.y - 8}" fill="#ff00ff" font-size="10" font-weight="bold">I${i}</text>`;
            });

            // Visualize regions
            analysisResults.regions.forEach((region, i) => {
                const color = region.type === 'center' ? '#ff6b6b' : '#4ecdc4';

                // Draw region boundary
                if (region.boundary.length > 0) {
                    const pathData = 'M ' + region.boundary.map(p => `${p.x} ${p.y}`).join(' L ') + ' Z';
                    overlayShapes += `<path d="${pathData}" fill="${color}" fill-opacity="0.15" stroke="${color}" stroke-width="2" stroke-dasharray="5,5"/>`;
                }

                // Draw centroid
                overlayShapes += `<circle cx="${region.centroid.x}" cy="${region.centroid.y}" r="3" fill="${color}" stroke="#fff" stroke-width="1"/>`;

                // Draw inscribed rectangle
                if (region.inscribedRectangle) {
                    const rect = region.inscribedRectangle;
                    overlayShapes += `<rect x="${rect.x}" y="${rect.y}" width="${rect.width}" height="${rect.height}" fill="none" stroke="#ffd93d" stroke-width="2" opacity="0.7"/>`;
                }

                // Draw inscribed ellipse
                if (region.inscribedEllipse) {
                    const ellipse = region.inscribedEllipse;
                    const rotation = (ellipse.rotation * 180 / Math.PI).toFixed(2);
                    overlayShapes += `<ellipse cx="${ellipse.center.x}" cy="${ellipse.center.y}" rx="${ellipse.semiMajorAxis}" ry="${ellipse.semiMinorAxis}" transform="rotate(${rotation} ${ellipse.center.x} ${ellipse.center.y})" fill="none" stroke="#6bcf7f" stroke-width="2" stroke-dasharray="3,3" opacity="0.7"/>`;
                }

                // Add region label
                overlayShapes += `<text x="${region.centroid.x}" y="${region.centroid.y + 20}" fill="${color}" font-size="12" font-weight="bold" text-anchor="middle">${region.type.toUpperCase()}</text>`;
                overlayShapes += `<text x="${region.centroid.x}" y="${region.centroid.y + 35}" fill="${color}" font-size="10" text-anchor="middle">Area: ${region.area.toFixed(0)}</text>`;
            });

            // Add analysis info panel
            overlayShapes += generateAnalysisInfoPanel(analysisResults);

            // Append overlay shapes to SVG
            const g = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('id', 'analysis-overlay');
            g.innerHTML = overlayShapes;
            svgElement.appendChild(g);

            // Serialize back to string
            const serializer = new XMLSerializer();
            return serializer.serializeToString(svgDoc);
        }

        /**
         * Generate info panel showing analysis results
         */
        function generateAnalysisInfoPanel(results) {
            let panel = '<g id="analysis-info-panel">';

            // Background panel
            panel += '<rect x="10" y="10" width="280" height="auto" rx="8" fill="#1a1a1a" fill-opacity="0.95" stroke="#6cf" stroke-width="2"/>';

            let y = 30;

            // Title
            panel += `<text x="20" y="${y}" fill="#6cf" font-size="14" font-weight="bold">Geometric Analysis</text>`;
            y += 25;

            // Curve count
            panel += `<text x="20" y="${y}" fill="#e0e0e0" font-size="11">Curves: ${results.curves.length}</text>`;
            y += 18;

            // Intersection count
            panel += `<text x="20" y="${y}" fill="#ff00ff" font-size="11">Intersections: ${results.intersections.length}</text>`;
            y += 18;

            // Region count
            panel += `<text x="20" y="${y}" fill="#4ecdc4" font-size="11">Regions: ${results.regions.length}</text>`;
            y += 22;

            // Region details
            results.regions.forEach((region, i) => {
                const color = region.type === 'center' ? '#ff6b6b' : '#4ecdc4';
                panel += `<text x="20" y="${y}" fill="${color}" font-size="10" font-weight="bold">${region.type.toUpperCase()} REGION</text>`;
                y += 15;
                panel += `<text x="30" y="${y}" fill="#e0e0e0" font-size="9">Area: ${region.area.toFixed(1)}px¬≤</text>`;
                y += 12;

                if (region.inscribedRectangle) {
                    panel += `<text x="30" y="${y}" fill="#ffd93d" font-size="9">Rect: ${region.inscribedRectangle.width.toFixed(0)}√ó${region.inscribedRectangle.height.toFixed(0)}px</text>`;
                    y += 12;
                }

                if (region.inscribedEllipse) {
                    panel += `<text x="30" y="${y}" fill="#6bcf7f" font-size="9">Ellipse: ${(region.inscribedEllipse.semiMajorAxis * 2).toFixed(0)}√ó${(region.inscribedEllipse.semiMinorAxis * 2).toFixed(0)}px</text>`;
                    y += 12;
                }

                y += 8;
            });

            // Adjust panel height
            panel = panel.replace('height="auto"', `height="${y + 10}"`);

            panel += '</g>';
            return panel;
        }

        // Helper functions for 3D shading
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function interpolateColor(color1, color2, factor) {
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);

            const r = Math.round(c1.r + (c2.r - c1.r) * factor);
            const g = Math.round(c1.g + (c2.g - c1.g) * factor);
            const b = Math.round(c1.b + (c2.b - c1.b) * factor);

            return `rgb(${r}, ${g}, ${b})`;
        }

        function calculateSurfaceNormal(t, points, tangents) {
            const tangent = tangents[Math.floor(t * (tangents.length - 1))];
            const normal = { x: -tangent.y, y: tangent.x };
            const len = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
            if (len > 0) {
                normal.x /= len;
                normal.y /= len;
            }
            return normal;
        }

        function calculateLighting(point, normal, lightPos, intensity, ambient, spec, shine, depthAmount) {
            const toLight = {
                x: lightPos.x - point.x,
                y: lightPos.y - point.y,
                z: lightPos.z
            };

            const distance = Math.sqrt(toLight.x * toLight.x + toLight.y * toLight.y + toLight.z * toLight.z);
            toLight.x /= distance;
            toLight.y /= distance;
            toLight.z /= distance;

            const normal3d = {
                x: normal.x,
                y: normal.y,
                z: depthAmount / 100.0
            };

            const normalLen = Math.sqrt(normal3d.x * normal3d.x + normal3d.y * normal3d.y + normal3d.z * normal3d.z);
            normal3d.x /= normalLen;
            normal3d.y /= normalLen;
            normal3d.z /= normalLen;

            const diffuse = Math.max(0, normal3d.x * toLight.x + normal3d.y * toLight.y + normal3d.z * toLight.z);

            const viewDir = { x: 0, y: 0, z: 1 };
            const dotNL = normal3d.x * toLight.x + normal3d.y * toLight.y + normal3d.z * toLight.z;
            const reflect = {
                x: 2 * dotNL * normal3d.x - toLight.x,
                y: 2 * dotNL * normal3d.y - toLight.y,
                z: 2 * dotNL * normal3d.z - toLight.z
            };

            const specular = Math.pow(Math.max(0, reflect.x * viewDir.x + reflect.y * viewDir.y + reflect.z * viewDir.z), shine);
            const totalLight = ambient + (diffuse * intensity) + (specular * spec * intensity);

            return Math.max(0, Math.min(1, totalLight));
        }

        function generateFlowAngle(state, size = 600) { // TODO: Make size dynamic based on container width
            const center = { x: size / 2, y: size / 2 };
            const radius = size * (1 / state.sides);
            const vertices = [];
            const angleStep = (2 * Math.PI) / state.sides;
            const rotRad = (state.rotation * Math.PI) / 180;

            // Calculate vertices
            for (let i = 0; i < state.sides; i++) {
                const angle = rotRad + i * angleStep;
                vertices.push({
                    x: center.x + radius * Math.cos(angle),
                    y: center.y + radius * Math.sin(angle)
                });
            }

            // Special case for n=1: circle
            if (state.sides === 1) {
                return `<svg viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="${center.x}" cy="${center.y}" r="${radius}" fill="#87ceeb" stroke="#4682b4" stroke-width="2" opacity="0.9"/>
                </svg>`;
            }

            // Special case for n=2: curved line
            if (state.sides === 2) {
                const v1 = vertices[0];
                const v2 = vertices[1];
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                const perpX = dy;
                const perpY = -dx;
                const baseLength = Math.sqrt(dx * dx + dy * dy);
                const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
                const offset = (baseLength / 2) * state.flowFactor;
                const cpX = midX + (perpX / perpLength) * offset;
                const cpY = midY + (perpY / perpLength) * offset;

                return `<svg viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
                    <path d="M ${v1.x} ${v1.y} Q ${cpX} ${cpY}, ${v2.x} ${v2.y}" fill="none" stroke="#4682b4" stroke-width="3" opacity="0.9"/>
                </svg>`;
            }

            // Build triangles
            const triangles = [];
            const apexAngle = (state.handleAngle * Math.PI) / 180;

            for (let i = 0; i < state.sides; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % state.sides];
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                const baseLength = Math.sqrt(dx * dx + dy * dy);
                const perpX = dy;
                const perpY = -dx;
                const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
                const height = (baseLength / 2) / Math.tan(apexAngle / 2);
                const thirdX = midX + (perpX / perpLength) * height;
                const thirdY = midY + (perpY / perpLength) * height;

                triangles.push({ v1, v2, third: { x: thirdX, y: thirdY } });
            }

            // 3D Shading parameters (sensible defaults)
            const lightPos = { x: size * 0.5, y: size * 0.2, z: 200 }; // Top-center with elevation
            const intensity = 1.0;
            const ambient = 0.3;
            const specularity = 0.3;
            const shininess = 10;
            const depthAmount = 30;
            const baseColor = '#87ceeb';
            const highlightColor = '#ffffff';
            const shadowColor = '#4682b4';

            // Calculate all points and tangents for shading
            const segments = 50;
            const allPoints = [];
            const allTangents = [];

            for (let i = 0; i < state.sides; i++) {
                const tri = triangles[i];
                const nextVertex = vertices[(i + 1) % state.sides];
                const cp1x = tri.v1.x + (tri.third.x - tri.v1.x) * state.flowFactor;
                const cp1y = tri.v1.y + (tri.third.y - tri.v1.y) * state.flowFactor;
                const cp2x = tri.v2.x + (tri.third.x - tri.v2.x) * state.flowFactor;
                const cp2y = tri.v2.y + (tri.third.y - tri.v2.y) * state.flowFactor;

                for (let j = 0; j <= segments; j++) {
                    const t = j / segments;
                    const mt = 1 - t;
                    const mt2 = mt * mt;
                    const mt3 = mt2 * mt;
                    const t2 = t * t;
                    const t3 = t2 * t;

                    const x = mt3 * tri.v1.x + 3 * mt2 * t * cp1x + 3 * mt * t2 * cp2x + t3 * nextVertex.x;
                    const y = mt3 * tri.v1.y + 3 * mt2 * t * cp1y + 3 * mt * t2 * cp2y + t3 * nextVertex.y;

                    const dx = 3 * mt2 * (cp1x - tri.v1.x) + 6 * mt * t * (cp2x - cp1x) + 3 * t2 * (nextVertex.x - cp2x);
                    const dy = 3 * mt2 * (cp1y - tri.v1.y) + 6 * mt * t * (cp2y - cp1y) + 3 * t2 * (nextVertex.y - cp2y);

                    const tangentLen = Math.sqrt(dx * dx + dy * dy);
                    allPoints.push({ x, y });
                    allTangents.push({
                        x: tangentLen > 0 ? dx / tangentLen : 0,
                        y: tangentLen > 0 ? dy / tangentLen : 0
                    });
                }
            }

            // Build shaded gradient mesh
            let shapes = '';

            // Add guide shapes if enabled
            if (state.showGuides) {
                triangles.forEach(tri => {
                    shapes += `<polygon points="${tri.v1.x},${tri.v1.y} ${tri.v2.x},${tri.v2.y} ${tri.third.x},${tri.third.y}" fill="#6cf" fill-opacity="0.1" stroke="#6cf" stroke-width="1" stroke-dasharray="3,3" opacity="0.3"/>`;
                });

                for (let i = 0; i < state.sides; i++) {
                    const tri = triangles[i];
                    const cp1x = tri.v1.x + (tri.third.x - tri.v1.x) * state.flowFactor;
                    const cp1y = tri.v1.y + (tri.third.y - tri.v1.y) * state.flowFactor;
                    const cp2x = tri.v2.x + (tri.third.x - tri.v2.x) * state.flowFactor;
                    const cp2y = tri.v2.y + (tri.third.y - tri.v2.y) * state.flowFactor;

                    shapes += `<circle cx="${cp1x}" cy="${cp1y}" r="2" fill="#f66" opacity="0.6"/>`;
                    shapes += `<circle cx="${cp2x}" cy="${cp2y}" r="2" fill="#6f6" opacity="0.6"/>`;
                    shapes += `<line x1="${tri.v1.x}" y1="${tri.v1.y}" x2="${cp1x}" y2="${cp1y}" stroke="#f66" stroke-width="1" stroke-dasharray="2,2" opacity="0.4"/>`;
                    shapes += `<line x1="${tri.v2.x}" y1="${tri.v2.y}" x2="${cp2x}" y2="${cp2y}" stroke="#6f6" stroke-width="1" stroke-dasharray="2,2" opacity="0.4"/>`;
                }
            }

            // Create gradient mesh with shading
            for (let i = 0; i < allPoints.length - 1; i++) {
                const p1 = allPoints[i];
                const p2 = allPoints[i + 1];
                const t = i / allPoints.length;

                const normal = calculateSurfaceNormal(t, allPoints, allTangents);
                const lighting = calculateLighting(p1, normal, lightPos, intensity, ambient, specularity, shininess, depthAmount);

                let color;
                if (lighting < 0.5) {
                    color = interpolateColor(shadowColor, baseColor, lighting * 2);
                } else {
                    color = interpolateColor(baseColor, highlightColor, (lighting - 0.5) * 2);
                }

                shapes += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="${color}" stroke-width="3" stroke-linecap="round"/>`;
            }

            return `<svg viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">${shapes}</svg>`;
        }

        function addKeyframe() {
            const state = getCurrentState();
            keyframes.push(state);
            activeKeyframeIndex = keyframes.length - 1;
            updateKeyframeDisplay();
        }

        function updateKeyframeDisplay() {
            const container = document.getElementById('keyframes-container');
            container.innerHTML = '';

            keyframes.forEach((kf, index) => {
                const div = document.createElement('div');
                div.className = 'keyframe' + (index === activeKeyframeIndex ? ' active' : '');
                div.onclick = () => selectKeyframe(index);

                const thumbnail = document.createElement('div');
                thumbnail.className = 'keyframe-thumbnail';
                thumbnail.innerHTML = generateFlowAngle(kf, 120);

                const label = document.createElement('div');
                label.className = 'keyframe-label';
                label.textContent = `Frame ${index + 1}`;

                div.appendChild(thumbnail);
                div.appendChild(label);
                container.appendChild(div);
            });
        }

        function selectKeyframe(index) {
            if (isPlaying) return;
            activeKeyframeIndex = index;
            applyState(keyframes[index]);
            updateKeyframeDisplay();
        }

        function loadPreset(name) {
            const presets = {
                triquetra: { sides: 3, flowFactor: -0.66, handleAngle: 60, rotation: -30 },
                flower: { sides: 6, flowFactor: -0.8, handleAngle: 30, rotation: 0 },
                star: { sides: 5, flowFactor: -1.8, handleAngle: 72, rotation: -18 },
                smooth: { sides: 8, flowFactor: -0.5, handleAngle: 22.5, rotation: 0 }
            };

            const preset = presets[name];
            if (preset) {
                document.getElementById('sides').value = preset.sides;
                document.getElementById('flow-factor').value = preset.flowFactor;
                document.getElementById('handle-angle').value = preset.handleAngle;
                document.getElementById('rotation').value = preset.rotation;
                updatePreview();
                saveToLocalStorage(); // Save preset selection
            }
        }

        // Load default configuration for first-time visitors
        function loadDefaultConfig() {
            // Use triquetra as the beautiful default
            document.getElementById('sides').value = 3;
            document.getElementById('flow-factor').value = -0.66;
            document.getElementById('handle-angle').value = 60;
            document.getElementById('rotation').value = -30;
        }

        function updatePulseAnimations() {
            // Stop all existing animations
            Object.values(pulseAnimations).forEach(anim => {
                if (anim) cancelAnimationFrame(anim);
            });
            pulseAnimations = {};

            // Update visual states
            const curveEnabled = document.getElementById('pulse-curve-enabled').checked;
            const angleEnabled = document.getElementById('pulse-angle-enabled').checked;
            const rotationEnabled = document.getElementById('pulse-rotation-enabled').checked;

            document.getElementById('pulse-curve-param').classList.toggle('active', curveEnabled);
            document.getElementById('pulse-angle-param').classList.toggle('active', angleEnabled);
            document.getElementById('pulse-rotation-param').classList.toggle('active', rotationEnabled);

            // Start animations
            if (curveEnabled) startPulse('curve');
            if (angleEnabled) startPulse('angle');
            if (rotationEnabled) startPulse('rotation');
        }

        function startPulse(param) {
            const range = parseFloat(document.getElementById(`pulse-${param}-range`).value);
            const speed = parseFloat(document.getElementById(`pulse-${param}-speed`).value);
            const easingName = document.getElementById(`pulse-${param}-easing`).value;
            const easing = easingFunctions[easingName];

            const baseValues = {
                curve: parseFloat(document.getElementById('flow-factor').value),
                angle: parseFloat(document.getElementById('handle-angle').value),
                rotation: parseFloat(document.getElementById('rotation').value)
            };

            const startTime = Date.now();

            function animate() {
                const elapsed = (Date.now() - startTime) / 1000;
                const cycle = (elapsed * speed) % 2;
                const t = cycle < 1 ? cycle : 2 - cycle;
                const easedT = easing(t);
                const oscillation = (easedT - 0.5) * 2 * range;

                if (param === 'curve') {
                    document.getElementById('flow-factor').value = baseValues.curve + oscillation;
                } else if (param === 'angle') {
                    document.getElementById('handle-angle').value = baseValues.angle + oscillation;
                } else if (param === 'rotation') {
                    document.getElementById('rotation').value = (baseValues.rotation + oscillation) % 360;
                }

                updatePreview();

                if (document.getElementById(`pulse-${param}-enabled`).checked) {
                    pulseAnimations[param] = requestAnimationFrame(animate);
                }
            }

            animate();
        }

        function togglePlay() {
            if (keyframes.length < 2) {
                alert('Add at least 2 keyframes to play animation');
                return;
            }

            isPlaying = !isPlaying;
            const btn = document.getElementById('play-btn');

            if (isPlaying) {
                btn.textContent = '‚è∏ Pause';
                btn.classList.add('playing');
                playStartTime = Date.now();
                playKeyframeAnimation();
            } else {
                btn.textContent = '‚ñ∂ Play';
                btn.classList.remove('playing');
                if (keyframeAnimation) {
                    cancelAnimationFrame(keyframeAnimation);
                    keyframeAnimation = null;
                }
            }
        }

        function interpolateState(state1, state2, t) {
            return {
                sides: Math.round(state1.sides + (state2.sides - state1.sides) * t),
                flowFactor: state1.flowFactor + (state2.flowFactor - state1.flowFactor) * t,
                handleAngle: state1.handleAngle + (state2.handleAngle - state1.handleAngle) * t,
                rotation: state1.rotation + (state2.rotation - state1.rotation) * t,
                showGuides: t < 0.5 ? state1.showGuides : state2.showGuides,
                fillContainer: t < 0.5 ? state1.fillContainer : state2.fillContainer
            };
        }

        function playKeyframeAnimation() {
            const frameLength = parseFloat(document.getElementById('frame-length').value) * 1000;
            const transitionPercent = parseFloat(document.getElementById('transition-time').value) / 100;
            const totalFrames = keyframes.length;
            const totalDuration = frameLength * totalFrames;

            function animate() {
                const elapsed = Date.now() - playStartTime;
                const loopTime = elapsed % totalDuration;
                const currentFrameIndex = Math.floor(loopTime / frameLength);
                const nextFrameIndex = (currentFrameIndex + 1) % totalFrames;
                const frameProgress = (loopTime % frameLength) / frameLength;

                let state;
                if (frameProgress < transitionPercent) {
                    // In transition
                    const prevFrameIndex = (currentFrameIndex - 1 + totalFrames) % totalFrames;
                    const t = frameProgress / transitionPercent;
                    const easedT = easingFunctions.easeInOut(t);
                    state = interpolateState(keyframes[prevFrameIndex], keyframes[currentFrameIndex], easedT);
                } else if (frameProgress > 1 - transitionPercent) {
                    // In transition to next
                    const t = (frameProgress - (1 - transitionPercent)) / transitionPercent;
                    const easedT = easingFunctions.easeInOut(t);
                    state = interpolateState(keyframes[currentFrameIndex], keyframes[nextFrameIndex], easedT);
                } else {
                    // Hold current frame
                    state = keyframes[currentFrameIndex];
                }

                applyState(state);

                if (isPlaying) {
                    keyframeAnimation = requestAnimationFrame(animate);
                }
            }

            animate();
        }

        // ===== URL SHARING FUNCTIONALITY =====

        /**
         * Encode current state to URL hash parameters
         * Uses compact parameter names for shorter URLs:
         * s=sides, c=curve, a=angle, r=rotation, g=guides
         * kf=keyframes (base64 encoded JSON array)
         */
        function encodeStateToURL(includeKeyframes = false) {
            const state = getCurrentState();
            const params = new URLSearchParams();

            // Add basic parameters with compact names
            params.set('s', state.sides);
            params.set('c', state.flowFactor.toFixed(3));
            params.set('a', state.handleAngle);
            params.set('r', state.rotation);
            params.set('g', state.showGuides ? '1' : '0');
            params.set('f', state.fillContainer ? '1' : '0');

            // Add pulse settings with compact names
            if (state.pulseSettings) {
                const ps = state.pulseSettings;

                // Curve pulse (pc* = pulse curve)
                params.set('pce', ps.curve.enabled ? '1' : '0');
                params.set('pcr', ps.curve.range.toFixed(2));
                params.set('pcs', ps.curve.speed.toFixed(1));
                params.set('pct', ps.curve.easing);

                // Angle pulse (pa* = pulse angle)
                params.set('pae', ps.angle.enabled ? '1' : '0');
                params.set('par', ps.angle.range);
                params.set('pas', ps.angle.speed.toFixed(1));
                params.set('pat', ps.angle.easing);

                // Rotation pulse (pr* = pulse rotation)
                params.set('pre', ps.rotation.enabled ? '1' : '0');
                params.set('prr', ps.rotation.range);
                params.set('prs', ps.rotation.speed.toFixed(1));
                params.set('prt', ps.rotation.easing);
            }

            // Optionally encode keyframes (if any exist and requested)
            if (includeKeyframes && keyframes.length > 0) {
                try {
                    // Compress keyframes data by only storing essential values
                    const compactKeyframes = keyframes.map(kf => ({
                        s: kf.sides,
                        c: parseFloat(kf.flowFactor.toFixed(3)),
                        a: kf.handleAngle,
                        r: kf.rotation,
                        g: kf.showGuides ? 1 : 0,
                        f: kf.fillContainer ? 1 : 0
                    }));

                    // Convert to JSON and then to base64
                    const jsonStr = JSON.stringify(compactKeyframes);
                    const base64 = btoa(jsonStr);
                    params.set('kf', base64);
                } catch (e) {
                    console.warn('Failed to encode keyframes:', e);
                }
            }

            return '#' + params.toString();
        }

        /**
         * Load shared configuration from database or URL hash
         * Checks for /share/[id] path first, then falls back to hash parameters
         */
        async function loadFromURL() {
            // Check if URL contains /share/[id] pattern
            const pathMatch = window.location.pathname.match(/\/share\/([a-zA-Z0-9_-]{8})/);

            if (pathMatch) {
                const shareId = pathMatch[1];
                return await loadSharedConfig(shareId);
            }

            // Fall back to hash-based loading
            const hash = window.location.hash.substring(1);
            if (!hash) return false;

            try {
                const params = new URLSearchParams(hash);
                let stateLoaded = false;

                // Parse basic parameters (compact names)
                if (params.has('s')) {
                    const sides = parseInt(params.get('s'));
                    if (sides >= 1 && sides <= 12) {
                        document.getElementById('sides').value = sides;
                        stateLoaded = true;
                    }
                }

                if (params.has('c')) {
                    const curve = parseFloat(params.get('c'));
                    if (!isNaN(curve)) {
                        document.getElementById('flow-factor').value = curve;
                        stateLoaded = true;
                    }
                }

                if (params.has('a')) {
                    const angle = parseFloat(params.get('a'));
                    if (angle >= 10 && angle <= 170) {
                        document.getElementById('handle-angle').value = angle;
                        stateLoaded = true;
                    }
                }

                if (params.has('r')) {
                    const rotation = parseFloat(params.get('r'));
                    if (!isNaN(rotation)) {
                        document.getElementById('rotation').value = rotation % 360;
                        stateLoaded = true;
                    }
                }

                if (params.has('g')) {
                    const guides = params.get('g') === '1';
                    document.getElementById('show-guides').checked = guides;
                    stateLoaded = true;
                }

                if (params.has('f')) {
                    const fillContainer = params.get('f') === '1';
                    document.getElementById('fill-container').checked = fillContainer;
                    stateLoaded = true;
                }

                // Parse pulse settings if present
                if (params.has('pce')) {
                    // Curve pulse
                    document.getElementById('pulse-curve-enabled').checked = params.get('pce') === '1';
                    if (params.has('pcr')) document.getElementById('pulse-curve-range').value = parseFloat(params.get('pcr'));
                    if (params.has('pcs')) document.getElementById('pulse-curve-speed').value = parseFloat(params.get('pcs'));
                    if (params.has('pct')) document.getElementById('pulse-curve-easing').value = params.get('pct');

                    // Angle pulse
                    document.getElementById('pulse-angle-enabled').checked = params.get('pae') === '1';
                    if (params.has('par')) document.getElementById('pulse-angle-range').value = parseFloat(params.get('par'));
                    if (params.has('pas')) document.getElementById('pulse-angle-speed').value = parseFloat(params.get('pas'));
                    if (params.has('pat')) document.getElementById('pulse-angle-easing').value = params.get('pat');

                    // Rotation pulse
                    document.getElementById('pulse-rotation-enabled').checked = params.get('pre') === '1';
                    if (params.has('prr')) document.getElementById('pulse-rotation-range').value = parseFloat(params.get('prr'));
                    if (params.has('prs')) document.getElementById('pulse-rotation-speed').value = parseFloat(params.get('prs'));
                    if (params.has('prt')) document.getElementById('pulse-rotation-easing').value = params.get('prt');

                    // Update pulse animations with restored settings
                    updatePulseAnimations();
                    stateLoaded = true;
                }

                // Parse keyframes if present
                if (params.has('kf')) {
                    try {
                        const base64 = params.get('kf');
                        const jsonStr = atob(base64);
                        const compactKeyframes = JSON.parse(jsonStr);

                        // Expand compact keyframes to full format
                        keyframes = compactKeyframes.map(kf => ({
                            sides: kf.s,
                            flowFactor: kf.c,
                            handleAngle: kf.a,
                            rotation: kf.r,
                            showGuides: kf.g === 1,
                            fillContainer: kf.f === 1
                        }));

                        if (keyframes.length > 0) {
                            activeKeyframeIndex = 0;
                            updateKeyframeDisplay();
                            stateLoaded = true;
                        }
                    } catch (e) {
                        console.warn('Failed to decode keyframes:', e);
                    }
                }

                return stateLoaded;
            } catch (e) {
                console.error('Failed to parse URL parameters:', e);
                return false;
            }
        }

        /**
         * Load configuration from database using share ID
         */
        async function loadSharedConfig(shareId) {
            try {
                const response = await fetch(`/api/share/${shareId}`);

                if (!response.ok) {
                    console.error('Failed to load shared configuration');
                    return false;
                }

                const data = await response.json();

                if (!data.success || !data.config) {
                    console.error('Invalid response from server');
                    return false;
                }

                const config = data.config;

                // Apply configuration to UI
                document.getElementById('sides').value = config.sides;
                document.getElementById('flow-factor').value = config.flowFactor;
                document.getElementById('handle-angle').value = config.handleAngle;
                document.getElementById('rotation').value = config.rotation;
                document.getElementById('show-guides').checked = config.showGuides;
                document.getElementById('fill-container').checked = config.fillContainer || false;

                // Load pulse settings if present
                if (config.pulseSettings) {
                    const ps = config.pulseSettings;

                    if (ps.curve) {
                        document.getElementById('pulse-curve-enabled').checked = ps.curve.enabled;
                        document.getElementById('pulse-curve-range').value = ps.curve.range;
                        document.getElementById('pulse-curve-speed').value = ps.curve.speed;
                        document.getElementById('pulse-curve-easing').value = ps.curve.easing;
                    }

                    if (ps.angle) {
                        document.getElementById('pulse-angle-enabled').checked = ps.angle.enabled;
                        document.getElementById('pulse-angle-range').value = ps.angle.range;
                        document.getElementById('pulse-angle-speed').value = ps.angle.speed;
                        document.getElementById('pulse-angle-easing').value = ps.angle.easing;
                    }

                    if (ps.rotation) {
                        document.getElementById('pulse-rotation-enabled').checked = ps.rotation.enabled;
                        document.getElementById('pulse-rotation-range').value = ps.rotation.range;
                        document.getElementById('pulse-rotation-speed').value = ps.rotation.speed;
                        document.getElementById('pulse-rotation-easing').value = ps.rotation.easing;
                    }

                    updatePulseAnimations();
                }

                // Load keyframes if present
                if (config.keyframes && config.keyframes.length > 0) {
                    keyframes = config.keyframes;
                    activeKeyframeIndex = 0;
                    updateKeyframeDisplay();
                }

                console.log(`Loaded shared configuration (viewed ${data.metadata.views} times)`);
                return true;

            } catch (error) {
                console.error('Error loading shared configuration:', error);
                return false;
            }
        }

        /**
         * Update URL hash with current state (without reloading page)
         */
        function updateURL() {
            const hash = encodeStateToURL(false);
            history.replaceState(null, '', hash);
        }

        /**
         * Share current configuration
         * Copies full URL with parameters to clipboard and shows notification
         */
        async function shareConfiguration() {
            try {
                const notification = document.getElementById('share-notification');
                notification.textContent = 'Creating share link...';
                notification.classList.add('show');

                // Prepare configuration data
                const state = getCurrentState();
                const configData = {
                    sides: state.sides,
                    flowFactor: state.flowFactor,
                    handleAngle: state.handleAngle,
                    rotation: state.rotation,
                    showGuides: state.showGuides,
                    fillContainer: state.fillContainer,
                    pulseSettings: state.pulseSettings,
                    keyframes: keyframes.length > 0 ? keyframes : undefined
                };

                // Send POST request to API
                const response = await fetch('/api/share', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(configData)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to create share link');
                }

                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to create share link');
                }

                // Copy short URL to clipboard
                const shortURL = data.fullUrl;
                await navigator.clipboard.writeText(shortURL);

                // Show success notification
                notification.textContent = `Short link copied! ${data.url}`;
                notification.classList.add('show');

                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);

                console.log('Share link created:', data);

            } catch (error) {
                console.error('Failed to share configuration:', error);

                // Fallback to hash-based sharing
                const notification = document.getElementById('share-notification');
                notification.textContent = 'Using fallback URL sharing...';

                try {
                    const hash = encodeStateToURL(true);
                    const shareURL = window.location.origin + window.location.pathname + hash;
                    await navigator.clipboard.writeText(shareURL);

                    notification.textContent = 'Link copied! (fallback mode)';
                    notification.classList.add('show');

                    setTimeout(() => {
                        notification.classList.remove('show');
                    }, 2000);

                    window.location.hash = hash;
                } catch (fallbackError) {
                    notification.textContent = 'Failed to copy link';
                    notification.classList.add('show');
                    setTimeout(() => {
                        notification.classList.remove('show');
                    }, 2000);
                }
            }
        }

        /**
         * Show the "Link copied!" notification with fade in/out animation
         */
        function showShareNotification() {
            const notification = document.getElementById('share-notification');
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }

        /**
         * Fallback copy method for browsers without clipboard API
         */
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();

            try {
                document.execCommand('copy');
                showShareNotification();
            } catch (err) {
                alert('Failed to copy link. Please copy manually:\n\n' + text);
            }

            document.body.removeChild(textArea);
        }

        // Auto-update URL when controls change (debounced)
        let urlUpdateTimeout = null;
        const originalUpdatePreview = updatePreview;

        updatePreview = function() {
            originalUpdatePreview();

            // Debounce URL updates to avoid excessive history entries
            clearTimeout(urlUpdateTimeout);
            urlUpdateTimeout = setTimeout(() => {
                if (!isPlaying) { // Don't update URL during animation playback
                    updateURL();
                }
            }, 500);
        };

        // ===== DOWNLOAD FUNCTIONALITY =====

        /**
         * Download current SVG as a file
         */
        function downloadSVG() {
            const svgElement = document.querySelector('#svg-preview svg');
            if (!svgElement) {
                alert('No SVG to download');
                return;
            }

            // Clone the SVG and ensure it has proper attributes
            const svgClone = svgElement.cloneNode(true);
            svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

            // Serialize the SVG
            const svgData = new XMLSerializer().serializeToString(svgClone);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const svgUrl = URL.createObjectURL(svgBlob);

            // Create download link
            const downloadLink = document.createElement('a');
            const state = getCurrentState();
            const filename = `flowangle-n${state.sides}-c${state.flowFactor.toFixed(2)}-a${state.handleAngle}.svg`;
            downloadLink.href = svgUrl;
            downloadLink.download = filename;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(svgUrl);
        }

        /**
         * Download current SVG as PNG
         */
        function downloadPNG() {
            const svgElement = document.querySelector('#svg-preview svg');
            if (!svgElement) {
                alert('No SVG to download');
                return;
            }

            // TODO: Make width and height dynamic based on container width
            // Get SVG dimensions respecting aspect ratio
            const viewBox = svgElement.getAttribute('viewBox');
            let width = 600; // TODO: Make width dynamic based on container width
            let height = 600; // TODO: Make height dynamic based on container width

            if (viewBox) {
                const [, , vbWidth, vbHeight] = viewBox.split(' ').map(Number);
                const aspectRatio = vbWidth / vbHeight;

                const bbox = svgElement.getBoundingClientRect();
                if (bbox.width && bbox.height) {
                    width = bbox.width;
                    height = bbox.height;
                } else if (bbox.width) {
                    width = bbox.width;
                    height = bbox.width / aspectRatio;
                } else if (bbox.height) {
                    height = bbox.height;
                    width = bbox.height * aspectRatio;
                } else {
                    // Use viewBox dimensions as fallback
                    width = vbWidth;
                    height = vbHeight;
                }
            } else {
                // Fallback to bbox if no viewBox
                const bbox = svgElement.getBoundingClientRect();
                width = bbox.width || 600; // TODO: Make width dynamic based on container width
                height = bbox.height || 600; // TODO: Make height dynamic based on container width
            }

            // Create canvas
            const canvas = document.createElement('canvas');
            const scale = 2; // 2x resolution for better quality
            canvas.width = width * scale;
            canvas.height = height * scale;
            const ctx = canvas.getContext('2d');
            ctx.scale(scale, scale);

            // Serialize SVG
            const svgClone = svgElement.cloneNode(true);
            svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            const svgData = new XMLSerializer().serializeToString(svgClone);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            // Create image
            const img = new Image();
            img.onload = function() {
                // Draw white background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);

                // Draw SVG
                ctx.drawImage(img, 0, 0, width, height);

                // Convert to PNG and download
                canvas.toBlob(function(blob) {
                    const state = getCurrentState();
                    const filename = `flowangle-n${state.sides}-c${state.flowFactor.toFixed(2)}-a${state.handleAngle}.png`;
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(blob);
                    downloadLink.download = filename;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    URL.revokeObjectURL(url);
                });
            };

            img.onerror = function() {
                alert('Failed to convert SVG to PNG');
                URL.revokeObjectURL(url);
            };

            img.src = url;
        }

        // ===== PARAMETER SPACE EXPLORER FUNCTIONS =====

        function openExplorer() {
            document.getElementById('parameter-explorer').style.display = 'flex';
            document.getElementById('explorer-overlay').classList.add('visible');

            // Set current n value
            document.getElementById('explore-n').value = document.getElementById('sides').value;
        }

        function closeExplorer() {
            document.getElementById('parameter-explorer').style.display = 'none';
            document.getElementById('explorer-overlay').classList.remove('visible');
        }

        function closeAllModals() {
            closeConstraintManager();
            closeExplorer();
        }

        async function startExploration() {
            const n = parseInt(document.getElementById('explore-n').value);
            const resolution = document.getElementById('explore-resolution').value;

            // Map resolution to step sizes
            const resolutionMap = {
                'coarse': { angleStep: 10, curveStep: 0.2 },
                'medium': { angleStep: 5, curveStep: 0.1 },
                'fine': { angleStep: 2, curveStep: 0.05 }
            };

            const steps = resolutionMap[resolution];

            // Show progress
            document.getElementById('exploration-progress').style.display = 'block';
            document.getElementById('exploration-progress').textContent = `Exploring n=${n}... This may take a moment.`;

            // Run exploration in a timeout to allow UI to update
            setTimeout(() => {
                try {
                    currentDiscoveries = parameterExplorer.exploreParameterSpace(n, {
                        handleAngleStep: steps.angleStep,
                        flowFactorStep: steps.curveStep
                    });

                    console.log(parameterExplorer.generateReport(n));

                    // Show results
                    displayExplorationResults();

                    // Hide progress
                    document.getElementById('exploration-progress').style.display = 'none';

                } catch (error) {
                    console.error('Exploration error:', error);
                    document.getElementById('exploration-progress').textContent = 'Exploration failed: ' + error.message;
                }
            }, 100);
        }

        function displayExplorationResults() {
            document.getElementById('exploration-results').style.display = 'block';

            // Update archetype counts
            Object.entries(currentDiscoveries.archetypes).forEach(([archetype, configs]) => {
                const countElement = document.getElementById(`archetype-${archetype}-count`);
                if (countElement) {
                    countElement.textContent = configs.length;
                }
            });

            // Default to showing fractalBloom archetype
            showArchetype('fractalBloom');
        }

        function showArchetype(archetypeName) {
            currentConfigList = currentDiscoveries.archetypes[archetypeName] || [];
            currentConfigIndex = 0;

            if (currentConfigList.length > 0) {
                displayCurrentConfig();
            } else {
                document.getElementById('config-details').innerHTML = `
                    <p style="color: #888; text-align: center;">No configurations found for ${archetypeName}</p>
                `;
                document.getElementById('config-counter').textContent = '0 / 0';
            }
        }

        function prevConfig() {
            if (currentConfigList.length === 0) return;
            currentConfigIndex = (currentConfigIndex - 1 + currentConfigList.length) % currentConfigList.length;
            displayCurrentConfig();
        }

        function nextConfig() {
            if (currentConfigList.length === 0) return;
            currentConfigIndex = (currentConfigIndex + 1) % currentConfigList.length;
            displayCurrentConfig();
        }

        function displayCurrentConfig() {
            if (currentConfigList.length === 0) return;

            const config = currentConfigList[currentConfigIndex];
            const state = config.state;
            const metrics = config.metrics;

            // Update counter
            document.getElementById('config-counter').textContent = `${currentConfigIndex + 1} / ${currentConfigList.length}`;

            // Build details HTML
            let html = '<div style="display: grid; gap: 12px;">';

            // Parameters
            html += '<div style="background: #2a2a2a; padding: 10px; border-radius: 4px;">';
            html += '<h4 style="color: #c6f; margin: 0 0 10px 0; font-size: 12px;">PARAMETERS</h4>';
            html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">`;
            html += `<div><span style="color: #888;">Sides:</span> <span style="color: #6cf;">${state.sides}</span></div>`;
            html += `<div><span style="color: #888;">Handle Angle:</span> <span style="color: #6cf;">${state.handleAngle}¬∞</span></div>`;
            html += `<div><span style="color: #888;">Flow:</span> <span style="color: #6cf;">${state.flowFactor}</span></div>`;
            html += `<div><span style="color: #888;">Rotation:</span> <span style="color: #6cf;">${state.rotation}¬∞</span></div>`;
            html += '</div></div>';

            // Metrics
            html += '<div style="background: #2a2a2a; padding: 10px; border-radius: 4px;">';
            html += '<h4 style="color: #c6f; margin: 0 0 10px 0; font-size: 12px;">METRICS</h4>';
            html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">`;
            html += `<div><span style="color: #888;">Complexity:</span> <span style="color: #ff6b6b;">${metrics.complexityScore.toFixed(3)}</span></div>`;
            html += `<div><span style="color: #888;">Simplicity:</span> <span style="color: #4ecdc4;">${metrics.simplicityScore.toFixed(3)}</span></div>`;
            html += `<div><span style="color: #888;">Roundness:</span> <span style="color: #ffd93d;">${metrics.roundness.toFixed(3)}</span></div>`;
            html += `<div><span style="color: #888;">Regularity:</span> <span style="color: #6bcf7f;">${metrics.regularity.toFixed(3)}</span></div>`;
            html += `<div><span style="color: #888;">Center Dom.:</span> <span style="color: #c6f;">${metrics.centerDominance.toFixed(3)}</span></div>`;
            html += `<div><span style="color: #888;">Intersections:</span> <span style="color: #ff00ff;">${metrics.intersectionCount}</span></div>`;
            html += '</div></div>';

            // Areas
            html += '<div style="background: #2a2a2a; padding: 10px; border-radius: 4px;">';
            html += '<h4 style="color: #c6f; margin: 0 0 10px 0; font-size: 12px;">AREAS</h4>';
            html += `<div style="font-size: 11px;">`;
            html += `<div style="margin-bottom: 5px;"><span style="color: #888;">Total:</span> <span style="color: #e0e0e0;">${metrics.totalArea.toFixed(0)}px¬≤</span></div>`;
            html += `<div style="margin-bottom: 5px;"><span style="color: #888;">Center:</span> <span style="color: #e0e0e0;">${metrics.centerArea.toFixed(0)}px¬≤</span></div>`;
            if (metrics.petalAreas.length > 0) {
                html += `<div><span style="color: #888;">Petals (avg):</span> <span style="color: #e0e0e0;">${(metrics.petalAreas.reduce((a,b) => a+b, 0) / metrics.petalAreas.length).toFixed(0)}px¬≤</span></div>`;
            }
            html += '</div></div>';

            html += '</div>';

            document.getElementById('config-details').innerHTML = html;
        }

        function loadSelectedConfig() {
            if (currentConfigList.length === 0) return;

            const config = currentConfigList[currentConfigIndex];
            const state = config.state;

            // Apply state to UI
            document.getElementById('sides').value = state.sides;
            document.getElementById('flow-factor').value = state.flowFactor;
            document.getElementById('handle-angle').value = state.handleAngle;
            document.getElementById('rotation').value = state.rotation;

            // Update preview
            updatePreview();

            // Close explorer
            closeExplorer();

            // Show notification
            showNotification(`Loaded configuration: n=${state.sides}, angle=${state.handleAngle}¬∞, curve=${state.flowFactor}`, 'success');
        }

        function exportExploration() {
            const json = parameterExplorer.exportDiscoveries();

            // Copy to clipboard
            navigator.clipboard.writeText(json).then(() => {
                showNotification('Exploration results copied to clipboard!', 'success');
            }).catch(err => {
                console.error('Failed to copy:', err);
                showNotification('Failed to copy to clipboard', 'error');
            });

            // Also download as file
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `flowangle-exploration-n${currentDiscoveries.n}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = 'notification show ' + type;

            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // ===== TIMELINE TAB FUNCTIONS =====

        function switchTimelineTab(tabName) {
            // Update tab buttons
            const tabs = document.querySelectorAll('.timeline-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            // Update tab content
            const contents = document.querySelectorAll('.timeline-tab-content');
            contents.forEach(content => content.classList.remove('active'));

            if (tabName === 'keyframes') {
                document.getElementById('keyframes-tab').classList.add('active');
            } else if (tabName === 'discoveries') {
                document.getElementById('discoveries-tab').classList.add('active');
                // Auto-load discoveries if not already loaded
                const currentN = parseInt(document.getElementById('sides').value);
                if (!discoveriesCache.has(currentN)) {
                    refreshDiscoveries();
                }
            }
        }

        async function refreshDiscoveries() {
            if (isExploringForDiscoveries) return;

            const currentN = parseInt(document.getElementById('sides').value);

            // Update display
            document.getElementById('discoveries-n-display').textContent = currentN;
            document.getElementById('discoveries-n-value').textContent = currentN;

            // Show loading state
            const container = document.getElementById('discoveries-container');
            container.innerHTML = '<div style="width: 100%; text-align: center; color: #6cf; padding: 40px;">üîç Exploring parameter space for n=' + currentN + '...<br><span style="font-size: 11px; color: #888;">This may take 10-30 seconds</span></div>';

            document.getElementById('discoveries-status').textContent = 'Exploring...';

            isExploringForDiscoveries = true;

            // Run exploration in background
            setTimeout(async () => {
                try {
                    // Use coarse resolution for quick discoveries
                    const discoveries = parameterExplorer.exploreParameterSpace(currentN, {
                        handleAngleStep: 10,
                        flowFactorStep: 0.2
                    });

                    // Cache results
                    discoveriesCache.set(currentN, discoveries);

                    // Display discoveries
                    displayDiscoveries(discoveries);

                    document.getElementById('discoveries-status').textContent = `Found ${getDiscoveriesCount(discoveries)} notable configurations`;

                } catch (error) {
                    console.error('Discovery exploration error:', error);
                    container.innerHTML = '<div style="width: 100%; text-align: center; color: #c44; padding: 40px;">‚ùå Exploration failed<br><span style="font-size: 11px;">' + error.message + '</span></div>';
                    document.getElementById('discoveries-status').textContent = 'Exploration failed';
                } finally {
                    isExploringForDiscoveries = false;
                }
            }, 100);
        }

        function getDiscoveriesCount(discoveries) {
            let count = 0;
            // Count extremes
            Object.values(discoveries.extremes).forEach(config => {
                if (config) count++;
            });
            // Count top archetype examples
            Object.values(discoveries.archetypes).forEach(configs => {
                if (configs.length > 0) count++;
            });
            return count;
        }

        function displayDiscoveries(discoveries) {
            const container = document.getElementById('discoveries-container');
            container.innerHTML = '';

            const configurationsToShow = [];

            // Add extremes (most important discoveries)
            const extremeLabels = {
                maxComplexity: 'üå∏ Max Complexity',
                maxSimplicity: 'üî≤ Max Simplicity',
                minCenterDominance: 'üå∫ Petal Dominant',
                maxRoundness: '‚ö™ Round Transition'
            };

            Object.entries(extremeLabels).forEach(([key, label]) => {
                const config = discoveries.extremes[key];
                if (config) {
                    configurationsToShow.push({
                        config: config,
                        label: label,
                        type: 'extreme'
                    });
                }
            });

            // Add top from each archetype
            const archetypeLabels = {
                fractalBloom: '‚ú® Fractal Bloom',
                gridAligned: 'üìê Grid Aligned',
                balanced: '‚öñÔ∏è Balanced'
            };

            Object.entries(archetypeLabels).forEach(([archetype, label]) => {
                const configs = discoveries.archetypes[archetype];
                if (configs && configs.length > 0) {
                    configurationsToShow.push({
                        config: configs[0],
                        label: label,
                        type: 'archetype'
                    });
                }
            });

            // Create thumbnail cards
            configurationsToShow.forEach((item, index) => {
                const card = createDiscoveryCard(item.config, item.label, index);
                container.appendChild(card);
            });

            if (configurationsToShow.length === 0) {
                container.innerHTML = '<div style="width: 100%; text-align: center; color: #888; padding: 40px;">No notable configurations found</div>';
            }
        }

        function createDiscoveryCard(config, label, index) {
            const card = document.createElement('div');
            card.className = 'keyframe';
            card.style.cursor = 'pointer';
            card.onclick = () => loadDiscoveryConfig(config);

            // Generate thumbnail SVG
            const thumbnailSVG = generateFlowAngle(config.state, 120);

            const thumbnail = document.createElement('div');
            thumbnail.className = 'keyframe-thumbnail';
            thumbnail.innerHTML = thumbnailSVG;

            const labelDiv = document.createElement('div');
            labelDiv.className = 'keyframe-label';
            labelDiv.innerHTML = `
                <div style="font-weight: bold; font-size: 10px; margin-bottom: 2px;">${label}</div>
                <div style="font-size: 9px; color: #888;">
                    a:${config.state.handleAngle}¬∞ c:${config.state.flowFactor.toFixed(1)}
                </div>
            `;

            card.appendChild(thumbnail);
            card.appendChild(labelDiv);

            return card;
        }

        function loadDiscoveryConfig(config) {
            const state = config.state;

            // Apply state to UI
            document.getElementById('sides').value = state.sides;
            document.getElementById('flow-factor').value = state.flowFactor;
            document.getElementById('handle-angle').value = state.handleAngle;
            document.getElementById('rotation').value = state.rotation;

            // Update preview
            updatePreview();

            // Show notification
            showNotification(`Loaded: ${state.handleAngle}¬∞, ${state.flowFactor}`, 'success');

            // Switch back to keyframes tab to see the result
            switchToKeyframesTab();
        }

        function switchToKeyframesTab() {
            const tabs = document.querySelectorAll('.timeline-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            tabs[0].classList.add('active');

            document.getElementById('keyframes-tab').classList.add('active');
            document.getElementById('discoveries-tab').classList.remove('active');
        }

        // ===== STEPPER CONTROLS & SMART LIMITING =====

        // Parameter limits tracking
        let parameterLimits = {
            flow: { min: -3, max: 1 },
            angle: { min: 10, max: 170 },
            spin: { min: 0, max: 360 }
        };
        let lastFeatureCount = 0;
        let staleIterations = 0;
        const STALE_THRESHOLD = 5;

        // Stepper functions
        function adjustFlow(delta) {
            const input = document.getElementById('flow-factor');
            let newValue = parseFloat(input.value) + delta;
            newValue = Math.max(parameterLimits.flow.min, Math.min(parameterLimits.flow.max, newValue));
            input.value = newValue.toFixed(2);
            onFlowChange();
        }

        function adjustAngle(delta) {
            const input = document.getElementById('handle-angle');
            let newValue = parseInt(input.value) + delta;
            const minAngle = parseFloat(input.min);
            const maxAngle = parseFloat(input.max);
            newValue = Math.max(minAngle, Math.min(maxAngle, newValue));
            input.value = newValue;
            updateAngleSlider();
        }

        function adjustSpin(delta) {
            const input = document.getElementById('rotation');
            let newValue = parseInt(input.value) + delta;
            newValue = Math.max(parameterLimits.spin.min, Math.min(parameterLimits.spin.max, newValue));
            input.value = newValue;
            onSpinChange();
        }

        // Change handlers
        function onFlowChange() {
            updateValueDisplay('flow');
            updatePreview();
            setTimeout(checkParameterLimits, 50);
        }

        function onAngleChange() {
            updateValueDisplay('angle');
            updatePreview();
            setTimeout(checkParameterLimits, 50);
        }

        function onSpinChange() {
            updateValueDisplay('spin');
            updatePreview();
            setTimeout(checkParameterLimits, 50);
        }

        function updateValueDisplay(param) {
            if (param === 'flow') {
                const value = document.getElementById('flow-factor').value;
                document.getElementById('flow-value').textContent = parseFloat(value).toFixed(2);
            } else if (param === 'angle') {
                const value = document.getElementById('handle-angle').value;
                document.getElementById('handle-angle-value').textContent = value + '¬∞';
            } else if (param === 'spin') {
                const value = document.getElementById('rotation').value;
                document.getElementById('rotation-value').textContent = value + '¬∞';
            }
        }

        // Smart limit detection
        function checkParameterLimits() {
            const state = getCurrentState();

            // Check for canvas explosion
            const hasExploded = detectCanvasExplosion(state);

            // Check for feature staleness
            const currentFeatureCount = getFeatureCount(state);
            if (currentFeatureCount === lastFeatureCount) {
                staleIterations++;
            } else {
                staleIterations = 0;
                lastFeatureCount = currentFeatureCount;
            }
            const isStale = staleIterations >= STALE_THRESHOLD;

            // Update button states
            updateStepperButtons(state, hasExploded, isStale);
        }

        function detectCanvasExplosion(state) {
            // Simple heuristic: if total area is more than 2x canvas area, it's exploded
            if (!analysisResults || !analysisResults.regions) return false;

            const canvasArea = 600 * 600;
            const totalArea = analysisResults.regions.reduce((sum, r) => sum + r.area, 0);

            return totalArea > canvasArea * 2 || totalArea < canvasArea * 0.01;
        }

        function getFeatureCount(state) {
            if (!analysisResults || !analysisResults.regions) return 0;
            return analysisResults.regions.length + (analysisResults.intersections?.length || 0);
        }

        function updateStepperButtons(state, hasExploded, isStale) {
            // Flow buttons
            const flowDec = document.getElementById('flow-dec');
            const flowInc = document.getElementById('flow-inc');
            const flowValue = state.flowFactor;

            flowDec.disabled = flowValue <= parameterLimits.flow.min;
            flowInc.disabled = flowValue >= parameterLimits.flow.max || (hasExploded && isStale);

            // Angle buttons
            const angleDec = document.getElementById('angle-dec');
            const angleInc = document.getElementById('angle-inc');
            const angleValue = state.handleAngle;

            angleDec.disabled = angleValue <= parameterLimits.angle.min;
            angleInc.disabled = angleValue >= parameterLimits.angle.max || (hasExploded && isStale);

            // Spin buttons (always enabled within range)
            const spinDec = document.getElementById('spin-dec');
            const spinInc = document.getElementById('spin-inc');
            const spinValue = state.rotation;

            spinDec.disabled = spinValue <= parameterLimits.spin.min;
            spinInc.disabled = spinValue >= parameterLimits.spin.max;
        }

        // Reset limits when sides change
        let sidesChangeListenerCleanup = null;

        function setupSidesChangeListener() {
            // Clean up old listener
            if (sidesChangeListenerCleanup) {
                sidesChangeListenerCleanup();
            }

            const sidesInput = document.getElementById('sides');
            const handler = function() {
                // Reset staleness tracking
                lastFeatureCount = 0;
                staleIterations = 0;

                // Re-enable all buttons (they'll be re-evaluated)
                setTimeout(checkParameterLimits, 100);
            };

            sidesInput.addEventListener('input', handler);

            // Return cleanup function
            sidesChangeListenerCleanup = () => {
                sidesInput.removeEventListener('input', handler);
            };
        }

        // ===== KEYBOARD CONTROLS =====

        let keyboardListenerCleanup = null;
        let pressedKeys = new Set();
        let keyboardAnimationFrame = null;
        let lastKeyboardUpdate = 0;
        let keyPressTimes = new Map(); // Track when each key was first pressed

        function setupKeyboardControls() {
            // Clean up old listener
            if (keyboardListenerCleanup) {
                keyboardListenerCleanup();
            }

            const keydownHandler = function(event) {
                // Don't intercept if user is typing in an input
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                    return;
                }

                const validKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ',', '.', '<', '>'];
                if (validKeys.includes(event.key)) {
                    event.preventDefault();

                    // Track when key was first pressed (for easing)
                    const isFirstPress = !pressedKeys.has(event.key);
                    if (isFirstPress) {
                        keyPressTimes.set(event.key, performance.now());

                        // Apply immediate action on first press (single tap support)
                        switch(event.key) {
                            case 'ArrowUp': adjustFlow(0.01); break;
                            case 'ArrowDown': adjustFlow(-0.01); break;
                            case 'ArrowLeft': adjustAngle(-1); break;
                            case 'ArrowRight': adjustAngle(1); break;
                            case '.':
                            case '>': adjustSides(1); break;
                            case ',':
                            case '<': adjustSides(-1); break;
                        }
                    }

                    pressedKeys.add(event.key);
                    showKeyboardHint(event.key);

                    // Start animation loop if not already running (for holding)
                    if (!keyboardAnimationFrame) {
                        keyboardAnimationFrame = requestAnimationFrame(updateFromKeyboard);
                    }
                }
            };

            const keyupHandler = function(event) {
                pressedKeys.delete(event.key);
                keyPressTimes.delete(event.key);

                // Stop animation loop if no keys pressed
                if (pressedKeys.size === 0 && keyboardAnimationFrame) {
                    cancelAnimationFrame(keyboardAnimationFrame);
                    keyboardAnimationFrame = null;
                }
            };

            document.addEventListener('keydown', keydownHandler);
            document.addEventListener('keyup', keyupHandler);

            // Return cleanup function
            keyboardListenerCleanup = () => {
                document.removeEventListener('keydown', keydownHandler);
                document.removeEventListener('keyup', keyupHandler);
                if (keyboardAnimationFrame) {
                    cancelAnimationFrame(keyboardAnimationFrame);
                    keyboardAnimationFrame = null;
                }
                pressedKeys.clear();
                keyPressTimes.clear();
            };
        }

        // Easing function for keyboard acceleration (ease-in-out-cubic)
        function keyboardEasing(t) {
            // t is time in seconds
            // Starts slow, accelerates, then caps
            const maxTime = 1.5; // Max acceleration time in seconds
            const normalizedTime = Math.min(t / maxTime, 1);

            // Ease-in-out cubic curve
            if (normalizedTime < 0.5) {
                return 4 * normalizedTime * normalizedTime * normalizedTime;
            } else {
                return 1 - Math.pow(-2 * normalizedTime + 2, 3) / 2;
            }
        }

        function getAccelerationMultiplier(key) {
            const startTime = keyPressTimes.get(key);
            if (!startTime) return 0.3; // Slow start if no time tracked

            const elapsedTime = (performance.now() - startTime) / 1000; // Convert to seconds
            const baseSpeed = 0.3; // Minimum speed multiplier
            const maxSpeed = 3.0; // Maximum speed multiplier

            const eased = keyboardEasing(elapsedTime);
            return baseSpeed + (maxSpeed - baseSpeed) * eased;
        }

        function updateFromKeyboard(timestamp) {
            // Throttle to ~60fps
            if (timestamp - lastKeyboardUpdate < 16) {
                keyboardAnimationFrame = requestAnimationFrame(updateFromKeyboard);
                return;
            }
            lastKeyboardUpdate = timestamp;

            // Apply all currently pressed keys with acceleration
            if (pressedKeys.has('ArrowUp')) {
                const mult = getAccelerationMultiplier('ArrowUp');
                adjustFlow(0.01 * mult);
            }
            if (pressedKeys.has('ArrowDown')) {
                const mult = getAccelerationMultiplier('ArrowDown');
                adjustFlow(-0.01 * mult);
            }
            if (pressedKeys.has('ArrowLeft')) {
                const mult = getAccelerationMultiplier('ArrowLeft');
                adjustAngle(-1 * mult);
            }
            if (pressedKeys.has('ArrowRight')) {
                const mult = getAccelerationMultiplier('ArrowRight');
                adjustAngle(1 * mult);
            }
            if (pressedKeys.has('.') || pressedKeys.has('>')) {
                const mult = getAccelerationMultiplier('.') || getAccelerationMultiplier('>');
                adjustSides(1 * mult);
            }
            if (pressedKeys.has(',') || pressedKeys.has('<')) {
                const mult = getAccelerationMultiplier(',') || getAccelerationMultiplier('<');
                adjustSides(-1 * mult);
            }

            // Continue animation loop
            if (pressedKeys.size > 0) {
                keyboardAnimationFrame = requestAnimationFrame(updateFromKeyboard);
            } else {
                keyboardAnimationFrame = null;
            }
        }

        function adjustSides(delta) {
            const input = document.getElementById('sides');
            let newValue = parseInt(input.value) + delta;
            newValue = Math.max(1, Math.min(12, newValue));
            input.value = newValue;
            updateSidesAndAngleRange();
        }

        function showKeyboardHint(key) {
            const hints = {
                'ArrowUp': '‚Üë Flow +',
                'ArrowDown': '‚Üì Flow -',
                'ArrowLeft': '‚Üê Angle -',
                'ArrowRight': '‚Üí Angle +',
                '.': '. Sides +',
                '>': '. Sides +',
                ',': ', Sides -',
                '<': ', Sides -'
            };

            const hint = hints[key];
            if (hint) {
                const hintEl = document.getElementById('keyboard-hint');
                if (hintEl) {
                    hintEl.textContent = hint;
                    hintEl.classList.add('show');
                    setTimeout(() => {
                        hintEl.classList.remove('show');
                    }, 800);
                }
            }
        }

        function toggleKeyboardShortcuts() {
            const shortcutsEl = document.getElementById('keyboard-shortcuts');
            shortcutsEl.classList.toggle('collapsed');
        }

        // Initialize on load
        window.addEventListener('load', () => {
            setupSidesChangeListener();
            setupKeyboardControls();
            setTimeout(checkParameterLimits, 200);
        });

        // Update n-display when sides slider changes
        document.getElementById('sides').addEventListener('input', function() {
            const n = this.value;
            document.getElementById('sides-value').textContent = n;
            document.getElementById('discoveries-n-display').textContent = n;
            document.getElementById('discoveries-n-value').textContent = n;
        });
    </script>
</body>
</html>
