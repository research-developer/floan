<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flowangle Interactive Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #1a1a2a;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background: #2a2a3a;
            padding: 20px;
            border-bottom: 2px solid #3a3a4a;
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 14px;
            color: #888;
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        canvas {
            border: 2px solid #3a3a4a;
            border-radius: 8px;
            background: #ffffff;
            cursor: crosshair;
        }

        .sidebar {
            width: 320px;
            background: #2a2a3a;
            border-left: 2px solid #3a3a4a;
            padding: 20px;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group h3 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #00ffcc;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control {
            margin-bottom: 15px;
        }

        .control label {
            display: block;
            font-size: 13px;
            margin-bottom: 6px;
            color: #ccc;
        }

        input[type="number"],
        input[type="color"],
        select {
            width: 100%;
            padding: 8px;
            background: #1a1a2a;
            border: 1px solid #3a3a4a;
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-control label {
            margin: 0;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #00ffcc;
            color: #1a1a2a;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            transition: background 0.2s;
        }

        button:hover {
            background: #00ddaa;
        }

        button.secondary {
            background: #4a4a5a;
            color: #fff;
        }

        button.secondary:hover {
            background: #5a5a6a;
        }

        .info {
            background: #3a3a4a;
            padding: 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #aaa;
            margin-top: 10px;
        }

        .handle-info {
            font-size: 11px;
            color: #888;
            margin-top: 15px;
            padding: 10px;
            background: #1a1a2a;
            border-radius: 4px;
        }

        .handle-info strong {
            color: #00ffcc;
        }

        .code-output {
            background: #1a1a2a;
            padding: 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #00ffcc;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            white-space: pre-wrap;
            word-break: break-all;
        }
    </style>
</head>
<body>
    <header>
        <h1>Flowangle Interactive Editor</h1>
        <p class="subtitle">Drag the control handles to adjust the bezier curves</p>
    </header>

    <div class="container">
        <div class="canvas-area">
            <canvas id="canvas" width="800" height="800"></canvas>
        </div>

        <div class="sidebar">
            <div class="control-group">
                <h3>Display Options</h3>

                <div class="checkbox-control">
                    <input type="checkbox" id="showTriangle" checked>
                    <label for="showTriangle">Show Reference Triangle</label>
                </div>

                <div class="checkbox-control">
                    <input type="checkbox" id="showHandles" checked>
                    <label for="showHandles">Show Control Handles</label>
                </div>

                <div class="checkbox-control">
                    <input type="checkbox" id="showCenter" checked>
                    <label for="showCenter">Show Center Point</label>
                </div>

                <div class="checkbox-control">
                    <input type="checkbox" id="coloredLobes">
                    <label for="coloredLobes">Color Each Lobe</label>
                </div>
            </div>

            <div class="control-group">
                <h3>Flowangle Parameters</h3>

                <div class="control">
                    <label>Handle Distance: <span id="distanceValue">0.50</span></label>
                    <input type="range" id="handleDistance" min="0" max="1.5" step="0.01" value="0.5">
                </div>

                <div class="control">
                    <label>Handle Position: <span id="positionValue">0.33</span></label>
                    <input type="range" id="handlePosition" min="0" max="0.5" step="0.01" value="0.33">
                </div>

                <button onclick="recalculateHandles()" class="secondary">Apply Parameters</button>
            </div>

            <div class="control-group">
                <h3>Style</h3>

                <div class="control">
                    <label>Lobe Stroke Width</label>
                    <input type="number" id="strokeWidth" min="1" max="20" value="8">
                </div>

                <div class="control">
                    <label>Lobe Color</label>
                    <input type="color" id="lobeColor" value="#000000">
                </div>
            </div>

            <div class="control-group">
                <h3>Export</h3>
                <button onclick="exportSVG()">Download SVG</button>
                <button onclick="copyControlPoints()" class="secondary">Copy Control Points</button>
                <button onclick="resetToDefault()" class="secondary">Reset to Default</button>
            </div>

            <div class="handle-info">
                <strong>Instructions:</strong><br>
                • Click and drag the blue control handles<br>
                • Red dots are triangle vertices (fixed)<br>
                • Each lobe has 2 control points<br>
                • Control points affect curve shape
            </div>

            <div id="coordsOutput" class="code-output"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas center
        const CENTER = { x: 400, y: 400 };
        const SIZE = 250;

        // Triangle vertices (fixed)
        const vertices = [
            { x: CENTER.x, y: CENTER.y - SIZE },  // Top
            { x: CENTER.x - SIZE * Math.cos(Math.PI / 6), y: CENTER.y + SIZE * Math.sin(Math.PI / 6) },  // Bottom-left
            { x: CENTER.x + SIZE * Math.cos(Math.PI / 6), y: CENTER.y + SIZE * Math.sin(Math.PI / 6) }   // Bottom-right
        ];

        // Calculate initial control points based on parameters
        function calculateControlPoints(handleDistance, handlePosition) {
            const lobes = [];

            for (let i = 0; i < 3; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % 3];

                // Midpoint of edge
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;

                // Vector from center to midpoint (outward)
                let outwardX = midX - CENTER.x;
                let outwardY = midY - CENTER.y;
                const outwardLen = Math.sqrt(outwardX * outwardX + outwardY * outwardY);
                outwardX /= outwardLen;
                outwardY /= outwardLen;

                // Handle offset (INWARD = negative)
                const offset = -handleDistance * SIZE;

                // Control point 1 (at handlePosition along edge)
                const t1 = handlePosition;
                const edge1X = v1.x + (v2.x - v1.x) * t1;
                const edge1Y = v1.y + (v2.y - v1.y) * t1;

                const c1x = edge1X + outwardX * offset;
                const c1y = edge1Y + outwardY * offset;

                // Control point 2 (at 1-handlePosition along edge)
                const t2 = 1 - handlePosition;
                const edge2X = v1.x + (v2.x - v1.x) * t2;
                const edge2Y = v1.y + (v2.y - v1.y) * t2;

                const c2x = edge2X + outwardX * offset;
                const c2y = edge2Y + outwardY * offset;

                lobes.push({
                    start: v1,
                    end: v2,
                    control1: { x: c1x, y: c1y },
                    control2: { x: c2x, y: c2y }
                });
            }

            return lobes;
        }

        // Initial parameters
        let handleDistance = 0.5;  // 0.0 to 1.0
        let handlePosition = 0.33; // 0.0 to 0.5 (position along edge)

        let lobes = calculateControlPoints(handleDistance, handlePosition);

        // Dragging state
        let draggedHandle = null;

        // Colors for lobes
        const lobeColors = ['#ff6b6b', '#4ecdc4', '#45b7d1'];

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const showTriangle = document.getElementById('showTriangle').checked;
            const showHandles = document.getElementById('showHandles').checked;
            const showCenter = document.getElementById('showCenter').checked;
            const coloredLobes = document.getElementById('coloredLobes').checked;
            const strokeWidth = parseInt(document.getElementById('strokeWidth').value);
            const lobeColor = document.getElementById('lobeColor').value;

            // Draw reference triangle
            if (showTriangle) {
                ctx.strokeStyle = 'rgba(128, 128, 128, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                ctx.lineTo(vertices[1].x, vertices[1].y);
                ctx.lineTo(vertices[2].x, vertices[2].y);
                ctx.closePath();
                ctx.stroke();
            }

            // Draw center point
            if (showCenter) {
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(CENTER.x, CENTER.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw lobes
            lobes.forEach((lobe, i) => {
                ctx.strokeStyle = coloredLobes ? lobeColors[i] : lobeColor;
                ctx.lineWidth = strokeWidth;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(lobe.start.x, lobe.start.y);
                ctx.bezierCurveTo(
                    lobe.control1.x, lobe.control1.y,
                    lobe.control2.x, lobe.control2.y,
                    lobe.end.x, lobe.end.y
                );
                ctx.stroke();

                // Draw control handles
                if (showHandles) {
                    // Control lines
                    ctx.strokeStyle = coloredLobes ? lobeColors[i] : 'rgba(0, 0, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);

                    ctx.beginPath();
                    ctx.moveTo(lobe.start.x, lobe.start.y);
                    ctx.lineTo(lobe.control1.x, lobe.control1.y);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(lobe.end.x, lobe.end.y);
                    ctx.lineTo(lobe.control2.x, lobe.control2.y);
                    ctx.stroke();

                    ctx.setLineDash([]);

                    // Control points
                    ctx.fillStyle = coloredLobes ? lobeColors[i] : '#0066ff';
                    ctx.beginPath();
                    ctx.arc(lobe.control1.x, lobe.control1.y, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(lobe.control2.x, lobe.control2.y, 8, 0, Math.PI * 2);
                    ctx.fill();

                    // White border for visibility
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(lobe.control1.x, lobe.control1.y, 8, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(lobe.control2.x, lobe.control2.y, 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Draw vertices
            if (showHandles) {
                vertices.forEach(v => {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(v.x, v.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            updateCoordinates();
        }

        function updateCoordinates() {
            const output = document.getElementById('coordsOutput');
            let text = 'Control Points:\n\n';
            lobes.forEach((lobe, i) => {
                text += `Lobe ${i}:\n`;
                text += `  C1: (${lobe.control1.x.toFixed(2)}, ${lobe.control1.y.toFixed(2)})\n`;
                text += `  C2: (${lobe.control2.x.toFixed(2)}, ${lobe.control2.y.toFixed(2)})\n\n`;
            });
            output.textContent = text;
        }

        function getHandleAtPosition(x, y) {
            const threshold = 12;

            for (let i = 0; i < lobes.length; i++) {
                const lobe = lobes[i];

                // Check control1
                const dist1 = Math.sqrt(
                    Math.pow(x - lobe.control1.x, 2) +
                    Math.pow(y - lobe.control1.y, 2)
                );
                if (dist1 < threshold) {
                    return { lobeIndex: i, control: 'control1' };
                }

                // Check control2
                const dist2 = Math.sqrt(
                    Math.pow(x - lobe.control2.x, 2) +
                    Math.pow(y - lobe.control2.y, 2)
                );
                if (dist2 < threshold) {
                    return { lobeIndex: i, control: 'control2' };
                }
            }

            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            draggedHandle = getHandleAtPosition(x, y);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggedHandle) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                lobes[draggedHandle.lobeIndex][draggedHandle.control] = { x, y };
                draw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedHandle = null;
        });

        // Function to recalculate handles based on parameters
        function recalculateHandles() {
            handleDistance = parseFloat(document.getElementById('handleDistance').value);
            handlePosition = parseFloat(document.getElementById('handlePosition').value);

            document.getElementById('distanceValue').textContent = handleDistance.toFixed(2);
            document.getElementById('positionValue').textContent = handlePosition.toFixed(2);

            lobes = calculateControlPoints(handleDistance, handlePosition);
            draw();
        }

        // Add event listeners for controls
        document.getElementById('showTriangle').addEventListener('change', draw);
        document.getElementById('showHandles').addEventListener('change', draw);
        document.getElementById('showCenter').addEventListener('change', draw);
        document.getElementById('coloredLobes').addEventListener('change', draw);
        document.getElementById('strokeWidth').addEventListener('input', draw);
        document.getElementById('lobeColor').addEventListener('input', draw);

        // Add listeners for parameter sliders
        document.getElementById('handleDistance').addEventListener('input', recalculateHandles);
        document.getElementById('handlePosition').addEventListener('input', recalculateHandles);

        function exportSVG() {
            const strokeWidth = document.getElementById('strokeWidth').value;
            const coloredLobes = document.getElementById('coloredLobes').checked;
            const lobeColor = document.getElementById('lobeColor').value;

            let svg = '<svg width="800" height="800" xmlns="http://www.w3.org/2000/svg">\n';
            svg += '  <rect width="800" height="800" fill="#ffffff"/>\n\n';

            // Triangle
            svg += '  <polygon points="';
            svg += vertices.map(v => `${v.x},${v.y}`).join(' ');
            svg += '" fill="none" stroke="rgba(128,128,128,0.3)" stroke-width="1"/>\n\n';

            // Lobes
            lobes.forEach((lobe, i) => {
                const color = coloredLobes ? lobeColors[i] : lobeColor;
                svg += `  <path d="M ${lobe.start.x},${lobe.start.y} `;
                svg += `C ${lobe.control1.x},${lobe.control1.y} `;
                svg += `${lobe.control2.x},${lobe.control2.y} `;
                svg += `${lobe.end.x},${lobe.end.y}" `;
                svg += `fill="none" stroke="${color}" stroke-width="${strokeWidth}" stroke-linecap="round"/>\n`;
            });

            svg += '</svg>';

            // Download
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'flowangle.svg';
            a.click();
            URL.revokeObjectURL(url);
        }

        function copyControlPoints() {
            let text = 'lobes = [\n';
            lobes.forEach((lobe, i) => {
                text += '    {\n';
                text += `        'start': Point(${lobe.start.x}, ${lobe.start.y}),\n`;
                text += `        'control1': Point(${lobe.control1.x.toFixed(2)}, ${lobe.control1.y.toFixed(2)}),\n`;
                text += `        'control2': Point(${lobe.control2.x.toFixed(2)}, ${lobe.control2.y.toFixed(2)}),\n`;
                text += `        'end': Point(${lobe.end.x}, ${lobe.end.y})\n`;
                text += '    }' + (i < lobes.length - 1 ? ',' : '') + '\n';
            });
            text += ']';

            navigator.clipboard.writeText(text);
            alert('Control points copied to clipboard!');
        }

        function resetToDefault() {
            handleDistance = 0.5;
            handlePosition = 0.33;

            document.getElementById('handleDistance').value = handleDistance;
            document.getElementById('handlePosition').value = handlePosition;
            document.getElementById('distanceValue').textContent = handleDistance.toFixed(2);
            document.getElementById('positionValue').textContent = handlePosition.toFixed(2);

            lobes = calculateControlPoints(handleDistance, handlePosition);
            draw();
        }

        // Initial draw
        draw();
    </script>
</body>
</html>
